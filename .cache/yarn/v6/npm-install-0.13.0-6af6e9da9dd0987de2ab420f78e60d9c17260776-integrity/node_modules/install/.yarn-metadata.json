{
  "manifest": {
    "author": {
      "name": "Ben Newman",
      "email": "bn@cs.stanford.edu"
    },
    "name": "install",
    "version": "0.13.0",
    "description": "Minimal JavaScript module loader",
    "keywords": [
      "modules",
      "require",
      "commonjs",
      "exports",
      "browser",
      "packaging",
      "packager",
      "install"
    ],
    "license": "MIT",
    "homepage": "http://github.com/benjamn/install",
    "repository": {
      "type": "git",
      "url": "git://github.com/benjamn/install.git"
    },
    "main": "install.js",
    "scripts": {
      "prepublish": "scripts/prepublish.sh",
      "docs": "scripts/docs.sh",
      "test": "mocha --reporter spec --full-trace test/run.js"
    },
    "devDependencies": {
      "docco": "^0.8.0",
      "mocha": "^5.0.0",
      "reify": "^0.18.1",
      "terser": "^3.16.0"
    },
    "engines": {
      "node": ">= 0.10"
    },
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-install-0.13.0-6af6e9da9dd0987de2ab420f78e60d9c17260776-integrity/node_modules/install/package.json",
    "readmeFilename": "README.md",
    "readme": "# install [![Build Status](https://travis-ci.org/benjamn/install.svg?branch=master)](https://travis-ci.org/benjamn/install) [![Greenkeeper badge](https://badges.greenkeeper.io/benjamn/install.svg)](https://greenkeeper.io/)\n\nThe [CommonJS module syntax](http://wiki.commonjs.org/wiki/Modules/1.1) is one of the most widely accepted conventions in the JavaScript ecosystem. Everyone seems to agree that `require` and `exports` are a reasonable way of expressing module dependencies and interfaces, and the tools for managing modular code are getting better all the time.\n\nMuch less of a consensus has developed around the best way to deliver CommonJS modules to a web browser, where the synchronous semantics of `require` pose a non-trivial implementation challenge. This module loader contributes to that confusion, yet also demonstrates that an amply-featured module loader need not stretch into the hundreds or thousands of lines.\n\nInstallation\n---\nFrom NPM:\n\n    npm install install\n\nFrom GitHub:\n\n    cd path/to/node_modules\n    git clone git://github.com/benjamn/install.git\n    cd install\n    npm install .\n\nUsage\n---\n\nThe first step is to create an `install` function by calling the\n`makeInstaller` method. Note that all of the options described below are\noptional:\n\n```js\nvar install = require(\"install\").makeInstaller({\n  // Optional list of file extensions to be appended to required module\n  // identifiers if they do not exactly match an installed module.\n  extensions: [\".js\", \".json\"],\n\n  // If defined, the options.fallback function will be called when no\n  // installed module is found for a required module identifier. Often\n  // options.fallback will be implemented in terms of the native Node\n  // require function, which has the ability to load binary modules.\n  fallback,\n\n  // Boolean flag indicating whether the installed code will be running in\n  // a web browser.\n  browser,\n\n  // List of fields to look for in package.json files to determine the\n  // main entry module of the package. The first field listed here whose\n  // value is a string will be used to resolve the entry module. Defaults\n  // to just [\"main\"], or [\"browser\", \"main\"] if options.browser is true.\n  mainFields: [\"browser\", \"main\"],\n});\n```\n\nThe second step is to install some modules by passing a nested tree of\nobjects and functions to the `install` function:\n\n```js\nvar require = install({\n  \"main.js\"(require, exports, module) {\n    // On the client, the \"assert\" module should be install-ed just like\n    // any other module. On the server, since \"assert\" is a built-in Node\n    // module, it may make sense to let the options.fallback function\n    // handle such requirements. Both ways work equally well.\n    var assert = require(\"assert\");\n\n    assert.strictEqual(\n      // This require function uses the same lookup rules as Node, so it\n      // will find \"package\" in the \"node_modules\" directory below.\n      require(\"package\").name,\n      \"/node_modules/package/entry.js\"\n    );\n\n    exports.name = module.id;\n  },\n\n  node_modules: {\n    package: {\n      // If package.json is not defined, a module called \"index.js\" will\n      // be used as the main entry point for the package. Otherwise the\n      // exports.main property will identify the entry point.\n      \"package.json\"(require, exports, module) {\n        exports.name = \"package\";\n        exports.version = \"0.1.0\";\n        exports.main = \"entry.js\";\n      },\n\n      \"entry.js\"(require, exports, module) {\n        exports.name = module.id;\n      }\n    }\n  }\n});\n```\n\nNote that the `install` function merely installs modules without\nevaluating them, so the third and final step is to `require` any entry\npoint modules that you wish to evaluate:\n\n```js\nconsole.log(require(\"./main\").name);\n// => \"/main.js\"\n```\n\nThis is the \"root\" `require` function returned by the `install`\nfunction. If you're using the `install` package in a CommonJS environment\nlike Node, be careful that you don't overwrite the `require` function\nprovided by that system.\n\nIf you need to change the behavior of the `module` object that each module\nfunction receives as its third parameter, the shared `Module` constructor\nis exposed as a property of the `install` function returned by the\n`makeInstaller` factory:\n\n```js\nvar install = makeInstaller(options);\nvar proto = install.Module.prototype;\n\n// Wrap all Module.prototype.require calls with some sort of logging.\nproto.require = wrapWithLogging(proto.require);\n\n// Add a new method available to all modules via module.newMethod(...).\nproto.newMethod = function () {...};\n```\n\nMany more examples of how to use the `install` package can be found in the\n[tests](https://github.com/benjamn/install/blob/master/test/run.js).\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2015 Benjamin Newman <ben@benjamn.com>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/install/-/install-0.13.0.tgz#6af6e9da9dd0987de2ab420f78e60d9c17260776",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/install/-/install-0.13.0.tgz",
    "hash": "6af6e9da9dd0987de2ab420f78e60d9c17260776",
    "integrity": "sha512-zDml/jzr2PKU9I8J/xyZBQn8rPCAY//UOYNmR01XwNwyfhEWObo2SWfSl1+0tm1u6PhxLwDnfsT/6jB7OUxqFA==",
    "registry": "npm",
    "packageName": "install",
    "cacheIntegrity": "sha512-zDml/jzr2PKU9I8J/xyZBQn8rPCAY//UOYNmR01XwNwyfhEWObo2SWfSl1+0tm1u6PhxLwDnfsT/6jB7OUxqFA== sha1-avbp2p3QmH3iq0IPeOYNnBcmB3Y="
  },
  "registry": "npm",
  "hash": "6af6e9da9dd0987de2ab420f78e60d9c17260776"
}
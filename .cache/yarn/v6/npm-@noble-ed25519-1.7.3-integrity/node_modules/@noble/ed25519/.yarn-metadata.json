{
  "manifest": {
    "name": "@noble/ed25519",
    "version": "1.7.3",
    "description": "Fastest JS implementation of ed25519. Independently audited, high-security, 0-dependency EDDSA, X25519 ECDH & ristretto255",
    "files": [
      "lib"
    ],
    "main": "lib/index.js",
    "module": "lib/esm/index.js",
    "types": "lib/index.d.ts",
    "scripts": {
      "build": "tsc -d && tsc -p tsconfig.esm.json",
      "build:release": "rollup -c rollup.config.js",
      "lint": "prettier --print-width 100 --single-quote --check index.ts",
      "test": "jest",
      "bench": "node test/benchmark/benchmark.js"
    },
    "author": {
      "name": "Paul Miller",
      "url": "https://paulmillr.com"
    },
    "homepage": "https://paulmillr.com/noble/",
    "repository": {
      "type": "git",
      "url": "https://github.com/paulmillr/noble-ed25519.git"
    },
    "license": "MIT",
    "browser": {
      "crypto": false
    },
    "devDependencies": {
      "@noble/hashes": "1.1.2",
      "@rollup/plugin-node-resolve": "13.3.0",
      "@types/jest": "28.1.1",
      "@types/node": "17.0.18",
      "fast-check": "3.0.0",
      "jest": "28.1.0",
      "micro-bmark": "0.2.0",
      "prettier": "2.6.2",
      "rollup": "2.75.5",
      "ts-jest": "28.0.4",
      "typescript": "4.7.3"
    },
    "keywords": [
      "ed25519",
      "edwards",
      "ristretto255",
      "decaf",
      "curve25519",
      "x25519",
      "elliptic",
      "elliptic curve",
      "curve",
      "elligator",
      "signature",
      "ecc",
      "eddsa",
      "RFC7748",
      "RFC8032",
      "ZIP215",
      "cryptography",
      "security"
    ],
    "exports": {
      ".": {
        "types": "./lib/index.d.ts",
        "import": "./lib/esm/index.js",
        "default": "./lib/index.js"
      }
    },
    "prettier": {
      "printWidth": 100,
      "singleQuote": true
    },
    "jest": {
      "testRegex": "/test/.*.ts",
      "transform": {
        "^.+\\.ts$": "ts-jest"
      },
      "useStderr": true,
      "bail": 2
    },
    "funding": [
      {
        "type": "individual",
        "url": "https://paulmillr.com/funding/"
      }
    ],
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-@noble-ed25519-1.7.3-integrity/node_modules/@noble/ed25519/package.json",
    "readmeFilename": "README.md",
    "readme": "# noble-ed25519 ![Node CI](https://github.com/paulmillr/noble-ed25519/workflows/Node%20CI/badge.svg) [![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n\n[Fastest](#speed) JS implementation of [ed25519](https://en.wikipedia.org/wiki/EdDSA),\nan elliptic curve that could be used for EDDSA signature scheme and X25519 ECDH key agreement.\n\nConforms to [RFC7748](https://datatracker.ietf.org/doc/html/rfc7748), [RFC8032](https://tools.ietf.org/html/rfc8032) and [ZIP215](https://zips.z.cash/zip-0215). Includes support for [ristretto255](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448): a technique for constructing prime order elliptic curve groups with non-malleable encodings.\n\n[**Audited**](#security) by an independent security firm. Check out [the online demo](https://paulmillr.com/noble/). See [ed25519-keygen](https://github.com/paulmillr/ed25519-keygen) if you need SSH/PGP/TOR/HD keys for the curve.\n\n### This library belongs to _noble_ crypto\n\n> **noble-crypto** — high-security, easily auditable set of contained cryptographic libraries and tools.\n\n- No dependencies, one small file\n- Easily auditable TypeScript/JS code\n- Supported in all major browsers and stable node.js versions\n- All releases are signed with PGP keys\n- Check out [homepage](https://paulmillr.com/noble/) & all libraries:\n  [curves](https://github.com/paulmillr/noble-curves)\n  ([secp256k1](https://github.com/paulmillr/noble-secp256k1),\n  [ed25519](https://github.com/paulmillr/noble-ed25519)),\n  [hashes](https://github.com/paulmillr/noble-hashes)\n\n## Usage\n\nUse NPM in node.js / browser, or include single file from\n[GitHub's releases page](https://github.com/paulmillr/noble-ed25519/releases):\n\n> npm install @noble/ed25519\n\n```js\n// Common.js and ECMAScript Modules (ESM)\nimport * as ed from '@noble/ed25519';\n// If you're using single file, use global variable instead: `window.nobleEd25519`\n\n// Supports both async and sync methods, see docs\n(async () => {\n  // keys, messages & other inputs can be Uint8Arrays or hex strings\n  // Uint8Array.from([0xde, 0xad, 0xbe, 0xef]) === 'deadbeef'\n  const privateKey = ed.utils.randomPrivateKey();\n  const message = Uint8Array.from([0xab, 0xbc, 0xcd, 0xde]);\n  const publicKey = await ed.getPublicKey(privateKey);\n  const signature = await ed.sign(message, privateKey);\n  const isValid = await ed.verify(signature, message, publicKey);\n})();\n```\n\nTo use the module with [Deno](https://deno.land),\nyou will need [import map](https://deno.land/manual/linking_to_external_code/import_maps):\n\n- `deno run --import-map=imports.json app.ts`\n- app.ts: `import * as ed from \"https://deno.land/x/ed25519/mod.ts\";`\n- imports.json: `{\"imports\": {\"crypto\": \"https://deno.land/std@0.153.0/node/crypto.ts\"}}`\n\n## API\n\n- [`getPublicKey(privateKey)`](#getpublickeyprivatekey)\n- [`sign(message, privateKey)`](#signmessage-privatekey)\n- [`verify(signature, message, publicKey)`](#verifysignature-message-publickey)\n- [`getSharedSecret(privateKey, publicKey)`](#getsharedsecretprivatekey-publickey)\n- [X25519 and curve25519](#x25519-and-curve25519)\n- [ristretto255](#ristretto255)\n- [Synchronous methods](#synchronous-methods)\n- [Utilities](#utilities)\n\n##### `getPublicKey(privateKey)`\n\n```typescript\nfunction getPublicKey(privateKey: Uint8Array | string | bigint): Promise<Uint8Array>;\n```\n\n- `privateKey: Uint8Array | string | bigint` will be used to generate public key. If you want to pass bigints,\n  ensure they are Big-Endian.\n- Returns `Promise<Uint8Array>`. Uses **promises**, because ed25519 uses SHA internally; and we're using built-in browser `window.crypto`, which returns `Promise`. Synchronous non-promise method is available for this and others: [see below](#synchronous-methods).\n\nTo generate ed25519 public key:\n\n1. private key is hashed with sha512, then first 32 bytes are taken from the hash\n2. 3 least significant bits of the first byte are cleared\n\n- Use `Point.fromPrivateKey(privateKey)` if you want `Point` instance instead\n- Use `Point.fromHex(publicKey)` if you want to convert hex / bytes into Point.\n  It will use decompression algorithm 5.1.3 of RFC 8032.\n- Use `utils.getExtendedPublicKey` if you need full SHA512 hash of seed\n\n##### `sign(message, privateKey)`\n\n```typescript\nfunction sign(message: Uint8Array | string, privateKey: Uint8Array | string): Promise<Uint8Array>;\n```\n\n- `message: Uint8Array | string` - message (not message hash) which would be signed\n- `privateKey: Uint8Array | string` - private key which will sign the hash\n- Returns EdDSA signature. You can consume it with `Signature.fromHex()` method:\n  - `Signature.fromHex(ed25519.sign(hash, privateKey))`\n\n##### `verify(signature, message, publicKey)`\n\n```typescript\nfunction verify(\n  signature: Uint8Array | string | Signature,\n  message: Uint8Array | string,\n  publicKey: Uint8Array | string | Point\n): Promise<boolean>;\n```\n\n- `signature: Uint8Array | string | Signature` - returned by the `sign` function\n- `message: Uint8Array | string` - message that needs to be verified\n- `publicKey: Uint8Array | string | Point` - e.g. that was generated from `privateKey` by `getPublicKey`\n- Returns `Promise<boolean>`\n\nVerifies signature. Compatible with [ZIP215](https://zips.z.cash/zip-0215), accepts:\n\n- `0 <= sig.R/publicKey < 2**256` (can be `>= curve.P` aka non-canonical encoding)\n- `0 <= sig.s < l`\n\n_Not compatible with RFC8032_ because rfc encorces canonical encoding of R/publicKey. There is no security risk in ZIP behavior, and there is no effect on honestly generated signatures. For additional info about verification strictness, check out [It’s 255:19AM](https://hdevalence.ca/blog/2020-10-04-its-25519am).\n\n##### `getSharedSecret(privateKey, publicKey)`\n\n```typescript\nfunction getSharedSecret(\n  privateKey: Uint8Array | string | bigint,\n  publicKey: Uint8Array | string\n): Promise<Uint8Array>;\n```\n\nConverts ed25519 private / public keys to Curve25519 and calculates\nElliptic Curve Diffie Hellman (ECDH) with X25519.\nConforms to [RFC7748](https://datatracker.ietf.org/doc/html/rfc7748).\n\n### X25519 and curve25519\n\n```js\nconst pub = ed25519.curve25519.scalarMultBase(privateKey);\nconst shared = ed25519.curve25519.scalarMult(privateKeyA, publicKeyB);\n```\n\nThe library includes namespace `curve25519` that you could use to calculate\nCurve25519 keys. It uses Montgomery Ladder specified in [RFC7748](https://datatracker.ietf.org/doc/html/rfc7748).\n\nYou cannot use ed25519 keys, because they are hashed with sha512. However, you can use\n`Point#toX25519()` method on ed25519 public keys. See implementation of `ed25519.getSharedSecret` for details.\n\n### Ristretto255\n\nEach Point in ed25519 has 8 different equivalent points. This can be a great pain for some algorithms\ne.g. ring signatures. In Tor, Ed25519 public key malleability would mean that every v3 onion service\nhas eight different addresses, causing mismatches with user expectations and potential gotchas for service operators.\nFixing this required expensive runtime checks in the v3 onion services protocol, requiring a full scalar multiplication,\npoint compression, and equality check. This check must be called in several places to validate that the onion service's\nkey does not contain a small torsion component.\n\nNo matter which one of these 8 equivalent points you give the Ristretto algorithm,\nit will give you exactly the same one. The other 7 points are no longer representable. Two caveats:\n\n1. Always use `RistrettoPoint.fromHex()` and `RistrettoPoint#toHex()`\n2. Never mix `ExtendedPoint` & `RistrettoPoint`: ristretto is not a subgroup of ed25519.\n   `ExtendedPoint` you are mixing with, may not be the representative for the set of possible points.\n\n```typescript\nimport { RistrettoPoint } from '@noble/ed25519';\n\n// Decode a byte-string representing a compressed Ristretto point.\n// Not compatible with Point.toHex()\nRistrettoPoint.fromHex(hex: Uint8Array | string): RistrettoPoint;\n\n// Encode a Ristretto point represented by the point (X:Y:Z:T) to Uint8Array\nRistrettoPoint#toHex(): Uint8Array;\n\n// Takes uniform output of 64-bit hash function like sha512 and converts it to RistrettoPoint\n// **Note:** this is one-way map, there is no conversion from point to hash.\nRistrettoPoint.hashToCurve(hash: Uint8Array | string): RistrettoPoint;\n```\n\nIt extends Mike Hamburg's Decaf approach to cofactor elimination to support cofactor-8 curves such as Curve25519.\n\nIn particular, this allows an existing Curve25519 library to implement a prime-order group with only a thin abstraction layer, and makes it possible for systems using Ed25519 signatures to be safely extended with zero-knowledge protocols, with no additional cryptographic assumptions and minimal code changes.\n\nFor more information on the topic, check out:\n\n- [Ristretto website](https://ristretto.group)\n- [irtf-cfrg-ristretto255-decaf448](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448) standard draft\n- [Exploiting Low Order Generators in One-Time Ring Signatures](https://jonasnick.github.io/blog/2017/05/23/exploiting-low-order-generators-in-one-time-ring-signatures/)\n- [Details of ristretto internals](https://monero.stackexchange.com/a/12171)\n- [Rust implementation with lots of comments](https://github.com/dalek-cryptography/curve25519-dalek/blob/967d8b6c0e67100401ad66125b7399ccf509ae22/src/ristretto.rs)\n\n### Synchronous methods\n\nThe library is using built-in async hash functions by default in order to follow its 0-dependency approach.\n\nThis means, built-in `getPublicKey`, `sync` and others are asynchronous. Some use-cases require\nsync versions of those. You can use them: all you need to do is make sure ed25519 knows\nhow to hash synchronously. Redefining `ed.utils.sha512Sync` is enough:\n\n```ts\nimport { sha512 } from '@noble/hashes/sha512';\ned.utils.sha512Sync = (...m) => sha512(ed.utils.concatBytes(...m));\nconst { getPublicKey, sign, verify, getExtendedPublicKey } = ed.sync;\n// Use it freely\ngetPublicKey(privKey);\n```\n\n### Utilities\n\nWe provide a bunch of useful utils and expose some internal classes.\n\n```typescript\n// Returns cryptographically secure random `Uint8Array` that could be used as private key\nutils.randomPrivateKey();\n\n// Native sha512 calculation\nutils.sha512(message: Uint8Array): Promise<Uint8Array>;\n\n// Modular division\nutils.mod(number: bigint, modulo = CURVE.P): bigint;\n\n// Inverses number over modulo\nutils.invert(number: bigint, modulo = CURVE.P): bigint;\n\n// Convert Uint8Array to hex string\nutils.bytesToHex(bytes: Uint8Array): string;\n\n// returns { head, prefix, scalar, point, pointBytes }\nutils.getExtendedPublicKey(privateKey);\n\n// Call it without arguments if you want your first calculation of public key to take normal time instead of ~20ms\nutils.precompute(W = 8, point = Point.BASE)\n\n// Elliptic curve point in Affine (x, y) coordinates.\nclass Point {\n  constructor(x: bigint, y: bigint);\n  static fromHex(hash: string);\n  static fromPrivateKey(privateKey: string | Uint8Array);\n  toX25519(): Uint8Array; // Converts to Curve25519 u coordinate in LE form\n  toRawBytes(): Uint8Array;\n  toHex(): string; // Compact representation of a Point\n  isTorsionFree(): boolean; // Multiplies the point by curve order\n  equals(other: Point): boolean;\n  negate(): Point;\n  add(other: Point): Point;\n  subtract(other: Point): Point;\n  multiply(scalar: bigint): Point;\n}\n// Elliptic curve point in Extended (x, y, z, t) coordinates.\nclass ExtendedPoint {\n  constructor(x: bigint, y: bigint, z: bigint, t: bigint);\n  static fromAffine(point: Point): ExtendedPoint;\n  toAffine(): Point;\n  equals(other: ExtendedPoint): boolean;\n  // Note: It does not check whether the `other` point is valid point on curve.\n  add(other: ExtendedPoint): ExtendedPoint;\n  subtract(other: ExtendedPoint): ExtendedPoint;\n  multiply(scalar: bigint): ExtendedPoint;\n  multiplyUnsafe(scalar: bigint): ExtendedPoint;\n}\n// Also (x, y, z, t)\nclass RistrettoPoint {\n  static hashToCurve(hex: Hex): RistrettoPoint;\n  static fromHex(hex: Hex): RistrettoPoint;\n  toRawBytes(): Uint8Array;\n  toHex(): string;\n  equals(other: RistrettoPoint): boolean;\n  add(other: RistrettoPoint): RistrettoPoint;\n  subtract(other: RistrettoPoint): RistrettoPoint;\n  multiply(scalar: number | bigint): RistrettoPoint;\n}\nclass Signature {\n  constructor(r: bigint, s: bigint);\n  static fromHex(hex: Hex): Signature;\n  toRawBytes(): Uint8Array;\n  toHex(): string;\n}\n\n// Curve params\ned25519.CURVE.P // 2 ** 255 - 19\ned25519.CURVE.l // 2 ** 252 + 27742317777372353535851937790883648493\ned25519.Point.BASE // new ed25519.Point(Gx, Gy) where\n// Gx = 15112221349535400772501151409588531511454012693041857206046113283949847762202n\n// Gy = 46316835694926478169428394003475163141307993866256225615783033603165251855960n;\n\ned25519.utils.TORSION_SUBGROUP; // The 8-torsion subgroup ℰ8.\n```\n\n## Security\n\nNoble is production-ready.\n\n1. The library has been audited by an independent security firm cure53: [PDF](https://cure53.de/pentest-report_ed25519.pdf). No vulnerabilities have been found. See [changes since audit](https://github.com/paulmillr/noble-ed25519/compare/1.6.0..main).\n2. The library has also been fuzzed by [Guido Vranken's cryptofuzz](https://github.com/guidovranken/cryptofuzz). You can run the fuzzer by yourself to check it.\n\nWe're using built-in JS `BigInt`, which is potentially vulnerable to [timing attacks](https://en.wikipedia.org/wiki/Timing_attack) as [per official spec](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#cryptography). But, _JIT-compiler_ and _Garbage Collector_ make \"constant time\" extremely hard to achieve in a scripting language. Which means _any other JS library doesn't use constant-time bigints_. Including bn.js or anything else. Even statically typed Rust, a language without GC, [makes it harder to achieve constant-time](https://www.chosenplaintext.ca/open-source/rust-timing-shield/security) for some cases. If your goal is absolute security, don't use any JS lib — including bindings to native ones. Use low-level libraries & languages. Nonetheless we've hardened implementation of ec curve multiplication to be algorithmically constant time.\n\nWe however consider infrastructure attacks like rogue NPM modules very important; that's why it's crucial to minimize the amount of 3rd-party dependencies & native bindings. If your app uses 500 dependencies, any dep could get hacked and you'll be downloading malware with every `npm install`. Our goal is to minimize this attack vector.\n\n## Speed\n\nBenchmarks done with Apple M2 on macOS 12 with Node.js 18.\n\n    getPublicKey(utils.randomPrivateKey()) x 8,627 ops/sec @ 115μs/op\n    sign x 4,355 ops/sec @ 229μs/op\n    verify x 852 ops/sec @ 1ms/op\n    verify (no decompression) x 975 ops/sec @ 1ms/op\n    Point.fromHex decompression x 13,512 ops/sec @ 74μs/op\n    ristretto255#hashToCurve x 6,419 ops/sec @ 155μs/op\n    ristretto255 round x 6,451 ops/sec @ 155μs/op\n    curve25519.scalarMultBase x 1,273 ops/sec @ 785μs/op\n    ed25519.getSharedSecret x 968 ops/sec @ 1ms/op\n\nCompare to alternative implementations:\n\n    ristretto255 x 669 ops/sec @ 1ms/op ± 1.41% (min: 1ms, max: 8ms)\n    sodium-native x 82,925 ops/sec @ 12μs/op\n\n    # tweetnacl@1.0.3 (fast)\n    getPublicKey x 2,087 ops/sec @ 479μs/op # aka scalarMultBase\n    sign x 667 ops/sec @ 1ms/op\n\n    # ristretto255@0.1.2\n    getPublicKey x 669 ops/sec @ 1ms/op ± 1.41% (min: 1ms, max: 8ms)\n\n    # sodium-native@3.4.1\n    # native bindings to libsodium, **node.js-only**\n    sign x 82,925 ops/sec @ 12μs/op\n\n## Contributing\n\n1. Clone the repository\n2. `npm install` to install build dependencies like TypeScript\n3. `npm run build` to compile TypeScript code\n4. `npm run test` to run jest on `test/index.ts`\n\n## License\n\nMIT (c) 2019 Paul Miller [(https://paulmillr.com)](https://paulmillr.com), see LICENSE file.\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2019 Paul Miller (https://paulmillr.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the “Software”), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/@noble/ed25519/-/ed25519-1.7.3.tgz",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/@noble/ed25519/-/ed25519-1.7.3.tgz",
    "hash": "",
    "integrity": "sha512-iR8GBkDt0Q3GyaVcIu7mSsVIqnFbkbRzGLWlvhwunacoLwt4J3swfKhfaM6rN6WY+TBGoYT1GtT1mIh2/jGbRQ==",
    "registry": "npm",
    "packageName": "@noble/ed25519",
    "cacheIntegrity": "sha512-iR8GBkDt0Q3GyaVcIu7mSsVIqnFbkbRzGLWlvhwunacoLwt4J3swfKhfaM6rN6WY+TBGoYT1GtT1mIh2/jGbRQ== sha1-V+Fne/aIU1S0ZsOOK2IMYvRacSM="
  },
  "registry": "npm",
  "hash": "891f060640edd10dc6c9a55c22eee64ac548aa715b91b47318b5a5be1c2e9da7282f0b78277b307ca85f68ceab37a598f93046a184f51ad4f5988876fe319b45"
}
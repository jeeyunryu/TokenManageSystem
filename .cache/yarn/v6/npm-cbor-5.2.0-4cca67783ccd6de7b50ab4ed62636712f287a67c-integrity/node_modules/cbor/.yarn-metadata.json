{
  "manifest": {
    "name": "cbor",
    "version": "5.2.0",
    "description": "Encode and parse data in the Concise Binary Object Representation (CBOR) data format (RFC7049).",
    "main": "./lib/cbor.js",
    "repository": {
      "type": "git",
      "url": "http://github.com/hildjj/node-cbor.git"
    },
    "homepage": "http://hildjj.github.io/node-cbor/",
    "browser": {
      "fs": false
    },
    "scripts": {
      "clean": "rm -rf coverage .nyc_output/ docs/api man/*",
      "lint": "eslint lib/*.js cli/lib/* cli/bin/* test/*.js",
      "doc": "jsdoc -c .jsdoc.conf",
      "coverage": "nyc npm test",
      "coveragehtml": "nyc -r html ava",
      "test": "ava",
      "man": "mkdir -p man; for f in man_src/*.md; do b=`basename $f`; marked-man $f -o man/${b%.md}.1; gzip -9f man/${b%.md}.1; done",
      "release": "npm version patch && git push --follow-tags && npm publish",
      "predev": "npm run coveragehtml",
      "dev": "light-server -q -s. -w 'lib/*.js # npm run doc' -w 'lib/*.js,test/*.js # npm run coveragehtml' -o /coverage/index.html",
      "coveralls": "nyc report --reporter=text-lcov | coveralls",
      "typecheck": "tsc --allowJs --checkJs --noEmit --target ES6 --moduleResolution node lib/*.js"
    },
    "keywords": [
      "coap",
      "cbor",
      "json"
    ],
    "author": {
      "name": "Joe Hildebrand",
      "email": "joe-github@cursive.net"
    },
    "contributors": [
      {
        "name": "Patrick Gansterer",
        "email": "paroga@paroga.com",
        "url": "http://paroga.com/"
      },
      {
        "name": "Artyom Yagilev",
        "email": "github@scorpi.org",
        "url": "http://scorpi.org/"
      },
      {
        "name": "Denis Lapaev",
        "email": "den@lapaev.me",
        "url": "http://lapaev.me/"
      },
      {
        "name": "Ruben Bridgewater",
        "email": "ruben@bridgewater.de"
      },
      {
        "name": "Burt Harris",
        "email": "Burt_Harris_cbor@azxs.33mail.com"
      }
    ],
    "ava": {
      "files": [
        "test/*.ava.js"
      ]
    },
    "devDependencies": {
      "@types/node": "*",
      "ava": "1.4.1",
      "concordance": "^5.0",
      "garbage": "0.0",
      "jsdoc": "^3.6.6",
      "light-server": "*",
      "minami": "*",
      "nyc": "^14.1.1"
    },
    "license": "MIT",
    "readmeFilename": "README.md",
    "dependencies": {
      "bignumber.js": "^9.0.1",
      "nofilter": "^1.0.4"
    },
    "engines": {
      "node": ">=6.0.0"
    },
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-cbor-5.2.0-4cca67783ccd6de7b50ab4ed62636712f287a67c-integrity/node_modules/cbor/package.json",
    "readme": "cbor\n====\n\nEncode and parse data in the Concise Binary Object Representation (CBOR) data format ([RFC7049](http://tools.ietf.org/html/rfc7049)).\n\nInstallation:\n------------\n\n```bash\n$ npm install --save cbor\n```\n\n**NOTE**\nThis package now requires node.js 8.3 or higher.  It will work on node.js 6, in\na less-tested, less-featureful way.  Please start upgrading if it is possible\nfor you.\n\nDocumentation:\n-------------\nSee the full API [documentation](http://hildjj.github.io/node-cbor/).\n\nFor a command-line interface, see [cbor-cli](https://github.com/hildjj/node-cbor/tree/master/cli).\n\nExample:\n```javascript\nvar cbor = require('cbor');\nvar assert = require('assert');\n\nvar encoded = cbor.encode(true); // returns <Buffer f5>\ncbor.decodeFirst(encoded, function(error, obj) {\n  // error != null if there was an error\n  // obj is the unpacked object\n  assert.ok(obj === true);\n});\n\n// Use integers as keys?\nvar m = new Map();\nm.set(1, 2);\nencoded = cbor.encode(m); // <Buffer a1 01 02>\n```\n\nAllows streaming as well:\n\n```javascript\nvar cbor = require('cbor');\nvar fs = require('fs');\n\nvar d = new cbor.Decoder();\nd.on('data', function(obj){\n  console.log(obj);\n});\n\nvar s = fs.createReadStream('foo');\ns.pipe(d);\n\nvar d2 = new cbor.Decoder({input: '00', encoding: 'hex'});\nd.on('data', function(obj){\n  console.log(obj);\n});\n```\n\nThere is also support for synchronous decodes:\n\n```javascript\ntry {\n  console.log(cbor.decodeFirstSync('02')); // 2\n  console.log(cbor.decodeAllSync('0202')); // [2, 2]\n} catch (e) {\n  // throws on invalid input\n}\n```\n\nThe sync encoding and decoding are exported as a\n[leveldb encoding](https://github.com/Level/levelup#custom_encodings), as\n`cbor.leveldb`.\n\n## highWaterMark\n\nThe synchronous routines for encoding and decoding will have problems with\nobjects that are larger than 16kB, which the default buffer size for Node\nstreams.  There are a few ways to fix this:\n\n1) pass in a `highWaterMark` option with the value of the largest buffer size you think you will need:\n\n```javascript\ncbor.encodeOne(Buffer.alloc(40000), {highWaterMark: 65535})\n```\n\n2) use stream mode.  Catch the `data`, `finish`, and `error` events.  Make sure to call `end()` when you're done.\n\n```javascript\nconst enc = new cbor.Encoder()\nenc.on('data', buf => /* send the data somewhere */)\nenc.on('error', console.error)\nenc.on('finish', () => /* tell the consumer we are finished */)\n\nenc.end(['foo', 1, false])\n```\n\n3) use `encodeAsync()`, which uses the approach from approach 2 to return a memory-inefficient promise for a Buffer.\n\n## Supported types\n\nThe following types are supported for encoding:\n\n* boolean\n* number (including -0, NaN, and Â±Infinity)\n* string\n* Array, Set (encoded as Array)\n* Object (including null), Map\n* undefined\n* Buffer\n* Date,\n* RegExp\n* url.URL\n* BigInt (If your JS version supports them)\n* [bignumber](https://github.com/MikeMcl/bignumber.js)\n\nDecoding supports the above types, including the following CBOR tag numbers:\n\n| Tag | Generated Type |\n|-----|----------------|\n| 0   | Date           |\n| 1   | Date           |\n| 2   | bignumber      |\n| 3   | bignumber      |\n| 4   | bignumber      |\n| 5   | bignumber      |\n| 32  | url.URL        |\n| 35  | RegExp         |\n\n## Adding new Encoders\n\nThere are several ways to add a new encoder:\n\n### `encodeCBOR` method\n\nThis is the easiest approach, if you can modify the class being encoded.  Add an\n`encodeCBOR` method to your class, which takes a single parameter of the encoder\ncurrently being used.  Your method should return `true` on success, else `false`.\nYour method may call `encoder.push(buffer)` or `encoder.pushAny(any)` as needed.\n\nFor example:\n\n```javascript\nclass Foo {\n  constructor () {\n    this.one = 1\n    this.two = 2\n  }\n  encodeCBOR (encoder) {\n    const tagged = new Tagged(64000, [this.one, this.two])\n    return encoder.pushAny(tagged)\n  }\n}\n```\n\nYou can also modify an existing type by monkey-patching an `encodeCBOR` function\nonto its prototype, but this isn't recommended.\n\n### `addSemanticType`\n\nSometimes, you want to support an existing type without modification to that\ntype.  In this case, call `addSemanticType(type, encodeFunction)` on an existing\n`Encoder` instance. The `encodeFunction` takes an encoder and an object to\nencode, for example:\n\n```javascript\nclass Bar {\n  constructor () {\n    this.three = 3\n  }\n}\nconst enc = new Encoder()\nenc.addSemanticType(Bar, (encoder, b) => {\n  encoder.pushAny(b.three)\n})\n```\n\n## Adding new decoders\n\nMost of the time, you will want to add support for decoding a new tag type.  If\nthe Decoder class encounters a tag it doesn't support, it will generate a `Tagged`\ninstance that you can handle or ignore as needed.  To have a specific type\ngenerated instead, pass a `tags` option to the `Decoder`'s constructor, consisting\nof an object with tag number keys and function values.  The function will be\npassed the decoded value associated with the tag, and should return the decoded\nvalue.  For the `Foo` example above, this might look like:\n\n```javascript\nconst d = new Decoder({tags: { 64000: (val) => {\n  // check val to make sure it's an Array as expected, etc.\n  const foo = new Foo()\n  foo.one = val[0]\n  foo.two = val[1]\n  return foo\n}}})\n```\n\nDevelopers\n----------\n\nThe tests for this package use a set of test vectors from RFC 7049 appendix A by importing a machine readable version of them from https://github.com/cbor/test-vectors. For these tests to work, you will need to use the command `git submodule update --init` after cloning or pulling this code.   See https://gist.github.com/gitaarik/8735255#file-git_submodules-md for more information.\n\nGet a list of build steps with `npm run`.  I use `npm run dev`, which rebuilds,\nruns tests, and refreshes a browser window with coverage metrics every time I\nsave a `.js` file.  If you don't want to run the fuzz tests every time, set\na `NO_GARBAGE` environment variable:\n\n```\nenv NO_GARBAGE=1 npm run dev\n```\n\n[![Build Status](https://travis-ci.com/hildjj/node-cbor.svg?branch=master)](https://travis-ci.com/hildjj/node-cbor)\n[![Coverage Status](https://coveralls.io/repos/hildjj/node-cbor/badge.svg?branch=master)](https://coveralls.io/r/hildjj/node-cbor?branch=master)\n[![Dependency Status](https://david-dm.org/hildjj/node-cbor.svg)](https://david-dm.org/hildjj/node-cbor)\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2014 Joe Hildebrand\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software is furnished to do so,\nsubject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\nFOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\nCOPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\nIN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\nCONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/cbor/-/cbor-5.2.0.tgz#4cca67783ccd6de7b50ab4ed62636712f287a67c",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/cbor/-/cbor-5.2.0.tgz",
    "hash": "4cca67783ccd6de7b50ab4ed62636712f287a67c",
    "integrity": "sha512-5IMhi9e1QU76ppa5/ajP1BmMWZ2FHkhAhjeVKQ/EFCgYSEaeVaoGtL7cxJskf9oCCk+XjzaIdc3IuU/dbA/o2A==",
    "registry": "npm",
    "packageName": "cbor",
    "cacheIntegrity": "sha512-5IMhi9e1QU76ppa5/ajP1BmMWZ2FHkhAhjeVKQ/EFCgYSEaeVaoGtL7cxJskf9oCCk+XjzaIdc3IuU/dbA/o2A== sha1-TMpneDzNbee1CrTtYmNnEvKHpnw="
  },
  "registry": "npm",
  "hash": "4cca67783ccd6de7b50ab4ed62636712f287a67c"
}
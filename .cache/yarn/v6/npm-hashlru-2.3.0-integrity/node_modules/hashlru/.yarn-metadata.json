{
  "manifest": {
    "name": "hashlru",
    "description": "simpler faster substitute for LRU",
    "version": "2.3.0",
    "homepage": "https://github.com/dominictarr/hashlru",
    "repository": {
      "type": "git",
      "url": "git://github.com/dominictarr/hashlru.git"
    },
    "dependencies": {},
    "devDependencies": {
      "istanbul": "^0.4.5"
    },
    "types": "index.d.ts",
    "scripts": {
      "test": "set -e; for t in test/*.js; do node $t; done",
      "cov": "istanbul cover test/*.js"
    },
    "author": {
      "name": "'Dominic Tarr'",
      "email": "dominic.tarr@gmail.com",
      "url": "dominictarr.com"
    },
    "license": "MIT",
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-hashlru-2.3.0-integrity/node_modules/hashlru/package.json",
    "readmeFilename": "README.md",
    "readme": "# hashlru\n\nSimpler, faster LRU cache algorithm\n\nA Least Recently Used cache is used to speedup requests to a key-value oriented resource,\nwhile making a bounded memory commitment.\n\nI've recently [benchmarked the various lru implementations available on npm](https://github.com/dominictarr/bench-lru)\nand found wildly varing performance. There where some that performed well overall,\nand others that performed extremely well in some cases, but poorly in others, due to\ncompromises made to maintain correctness.\n\nAfter writing the benchmark, of course I had to try my hand at my own LRU implementation.\nI soon found a few things, LRUs are quite difficult to implement, first of all contain a linked\nlist. LRUs use a linked list to maintain the order\nthat keys have been accessed, so that when the cache fills, the old values\n(which presumably are the least likely to be needed again) can be removed from the cache.\nLinked Lists are not easy to implement correctly!\n\nThen I discovered why some of the fast algorithms where so slow - they used `delete cache[key]`\nwhich is much slower than `cache[key] = value`, much much slower.\n\nSo, why looking for a way to avoid `delete` I had an idea - have two cache objects,\nand when one fills - create a new one and start putting items in that, and then it's sufficiently\nfull, throw it away. It avoids delete, at at max, only commits us to only N values and between N and 2N keys.\n\nThen I realized with this pattern, you _don't actually need_ the linked list anymore!\nThis makes a N-2N least recently used cache very very simple. This both has performance benefits,\nand it's also very easy to verify it's correctness.\n\nThis algorithm does not give you an ordered list of the N most recently used items,\nbut you do not really need that! The property of dropping the least recent items is still preserved.\n\nsee a [benchmark](https://github.com/dominictarr/bench-lru) of this against\nthe other LRU implementations on npm.\n\n## example\n\n``` js\nvar HLRU = require('hashlru')\nvar lru = HLRU(100)\nlru.set(key, value)\nlru.get(key)\n```\n\n## algorithm\n\ncreate two caches - `old_cache` and `new_cache`, and a counter, `size`.\n\nWhen an `key, value` pair is added, if `key` is already in `new_cache` update the value,\nnot currently in `new_cache`, set `new_cache[key] = value`.\nIf the key was _not_ already in `new_cache` then `size` is incremented.\nIf `size > max`, move the `old_cache = new_cache`, reset `size = 0`, and initialize a new `new_cache={}`\n\nTo get a `key`, check if `new_cache` contains key, and if so, return it.\nIf not, check if it is in `old_cache` and if so, move that value to `new_cache`, and increment `size`.\nIf `size > max`, move the `old_cache = new_cache`, reset `size = 0`, and initialize a new `new_cache={}`\n\n## complexity\n\nWrites are O(1) on average, like a hash table.\n\nWhen implemented in a garbage collected language, the old cache is thrown away when the new cache is\nfull. To better manage memory usage, it could also be implemented as two fixes sized hash tables.\nIn this case, instead of discarding the old cache, it would be zeroed. This means at most every N\nwrites when the caches are rotated, that write will require N operations (to clear the old cache)\n\nThis still averages out to O(1) but it does cost O(N) but only every N writes (except for updates)\nso N/N is still 1.\n\n## HashLRU (max) => lru\n\ninitialize a lru object.\n\n### lru.get (key) => value | undefined\n\nReturns the value in the cache, or `undefined` if the value is not in the cache.\n\n### lru.set(key, value)\n\nupdate the value for key.\n\n### lru.has(key) => boolean\n\nChecks if the `key` is in the cache.\n\n### lru.remove(key)\n\nRemoves the `key` from the cache.\n\n### lru.clear()\n\nEmpties the entire cache.\n\n## License\n\nMIT\n\n\n\n\n",
    "licenseText": "Copyright (c) 2016 'Dominic Tarr'\n\nPermission is hereby granted, free of charge, \nto any person obtaining a copy of this software and \nassociated documentation files (the \"Software\"), to \ndeal in the Software without restriction, including \nwithout limitation the rights to use, copy, modify, \nmerge, publish, distribute, sublicense, and/or sell \ncopies of the Software, and to permit persons to whom \nthe Software is furnished to do so, \nsubject to the following conditions:\n\nThe above copyright notice and this permission notice \nshall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, \nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES \nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR \nANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, \nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE \nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/hashlru/-/hashlru-2.3.0.tgz",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/hashlru/-/hashlru-2.3.0.tgz",
    "hash": "",
    "integrity": "sha512-0cMsjjIC8I+D3M44pOQdsy0OHXGLVz6Z0beRuufhKa0KfaD2wGwAev6jILzXsd3/vpnNQJmWyZtIILqM1N+n5A==",
    "registry": "npm",
    "packageName": "hashlru",
    "cacheIntegrity": "sha512-0cMsjjIC8I+D3M44pOQdsy0OHXGLVz6Z0beRuufhKa0KfaD2wGwAev6jILzXsd3/vpnNQJmWyZtIILqM1N+n5A== sha1-XcFZKLP2lhogVkFrs6SRAhb9+1E="
  },
  "registry": "npm",
  "hash": "d1c32c8e3202f08f83dcce38a4e41db32d0e1d718b573e99d1b791bae7e129ad0a7da0f6c06c007afea320bcd7b1ddffbe99cd409996c99b4820ba8cd4dfa7e4"
}
{
  "manifest": {
    "name": "@ipld/car",
    "version": "3.2.4",
    "description": "Content Addressable aRchive format reader and writer",
    "main": "./cjs/car.js",
    "types": "./types/car.d.ts",
    "scripts": {
      "lint": "standard",
      "build": "npm run build:js && npm run build:types",
      "build:js": "ipjs build --tests --main && npm run build:copy",
      "build:copy": "mkdir -p dist/examples/ && cp -a tsconfig.json *.js *.ts lib test dist/ && cp examples/*.* dist/examples/",
      "build:types": "tsc --build && mv types dist",
      "test:cjs": "rm -rf dist && npm run build && cp test/go.car dist/cjs/node-test/ && mocha dist/cjs/node-test/test-*.js && mocha dist/cjs/node-test/node-test-*.js && npm run test:cjs:browser",
      "test:esm": "rm -rf dist && npm run build && cp test/go.car dist/esm/node-test/ && mocha dist/esm/node-test/test-*.js && mocha dist/esm/node-test/node-test-*.js && npm run test:esm:browser",
      "test:node": "c8 --check-coverage --branches 100 --functions 100 --lines 100 mocha test/test-*.js test/node-test-*.js",
      "test:cjs:browser": "polendina --page --worker --serviceworker --cleanup dist/cjs/browser-test/test-*.js",
      "test:esm:browser": "polendina --page --worker --serviceworker --cleanup dist/esm/browser-test/test-*.js",
      "test": "npm run lint && npm run test:node && npm run test:cjs && npm run test --prefix examples/",
      "test:ci": "npm run lint && npm run test:node && npm run test:esm && npm run test:cjs && npm run test --prefix examples/",
      "coverage": "c8 --reporter=html --reporter=text mocha test/test-*.js && npx st -d coverage -p 8888",
      "docs": "jsdoc4readme --readme --description-only lib/reader*.js lib/indexed-reader.js lib/iterator.js lib/indexer.js lib/writer*.js"
    },
    "keywords": [
      "car",
      "ipld",
      "ipfs",
      "multiformats"
    ],
    "author": {
      "name": "Rod",
      "email": "rod@vagg.org",
      "url": "http://r.va.gg/"
    },
    "license": "(Apache-2.0 AND MIT)",
    "exports": {
      ".": {
        "browser": "./esm/car-browser.js",
        "require": "./cjs/car.js",
        "import": "./esm/car.js"
      },
      "./decoder": {
        "browser": "./esm/lib/decoder.js",
        "require": "./cjs/lib/decoder.js",
        "import": "./esm/lib/decoder.js"
      },
      "./reader": {
        "browser": "./esm/lib/reader-browser.js",
        "require": "./cjs/lib/reader.js",
        "import": "./esm/lib/reader.js"
      },
      "./indexed-reader": {
        "browser": "./esm/lib/indexed-reader-browser.js",
        "require": "./cjs/lib/indexed-reader.js",
        "import": "./esm/lib/indexed-reader.js"
      },
      "./indexer": {
        "browser": "./esm/lib/indexer.js",
        "require": "./cjs/lib/indexer.js",
        "import": "./esm/lib/indexer.js"
      },
      "./iterator": {
        "browser": "./esm/lib/iterator.js",
        "require": "./cjs/lib/iterator.js",
        "import": "./esm/lib/iterator.js"
      },
      "./writer": {
        "browser": "./esm/lib/writer-browser.js",
        "require": "./cjs/lib/writer.js",
        "import": "./esm/lib/writer.js"
      }
    },
    "dependencies": {
      "@ipld/dag-cbor": "^7.0.0",
      "multiformats": "^9.5.4",
      "varint": "^6.0.0"
    },
    "devDependencies": {
      "@ipld/dag-pb": "^2.1.14",
      "@types/chai": "^4.3.0",
      "@types/chai-as-promised": "^7.1.4",
      "@types/mocha": "^9.0.0",
      "@types/node": "^17.0.0",
      "@types/varint": "^6.0.0",
      "@typescript-eslint/eslint-plugin": "^5.6.0",
      "@typescript-eslint/parser": "^5.6.0",
      "c8": "^7.10.0",
      "chai": "^4.3.4",
      "chai-as-promised": "^7.1.1",
      "ipjs": "^5.2.0",
      "ipld-garbage": "^4.0.10",
      "jsdoc4readme": "^1.4.0",
      "mocha": "^9.1.3",
      "polendina": "~2.0.1",
      "standard": "^16.0.4",
      "typescript": "~4.6.2"
    },
    "standard": {
      "ignore": [
        "dist"
      ]
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/ipld/js-car.git"
    },
    "bugs": {
      "url": "https://github.com/ipld/js-car/issues"
    },
    "homepage": "https://github.com/ipld/js-car#readme",
    "typesVersions": {
      "*": {
        "reader": [
          "types/lib/reader.d.ts"
        ],
        "decoder": [
          "types/lib/decoder.d.ts"
        ],
        "indexed-reader": [
          "types/lib/indexed-reader.d.ts"
        ],
        "indexer": [
          "types/lib/indexer.d.ts"
        ],
        "iterator": [
          "types/lib/iterator.d.ts"
        ],
        "writer": [
          "types/lib/writer.d.ts"
        ],
        "*": [
          "types/*"
        ],
        "types/*": [
          "types/*"
        ]
      }
    },
    "release": {
      "branches": [
        "master"
      ],
      "plugins": [
        [
          "@semantic-release/commit-analyzer",
          {
            "preset": "conventionalcommits",
            "releaseRules": [
              {
                "breaking": true,
                "release": "major"
              },
              {
                "revert": true,
                "release": "patch"
              },
              {
                "type": "feat",
                "release": "minor"
              },
              {
                "type": "fix",
                "release": "patch"
              },
              {
                "type": "chore",
                "release": "patch"
              },
              {
                "type": "docs",
                "release": "patch"
              },
              {
                "type": "test",
                "release": "patch"
              },
              {
                "scope": "no-release",
                "release": false
              }
            ]
          }
        ],
        [
          "@semantic-release/release-notes-generator",
          {
            "preset": "conventionalcommits",
            "presetConfig": {
              "types": [
                {
                  "type": "feat",
                  "section": "Features"
                },
                {
                  "type": "fix",
                  "section": "Bug Fixes"
                },
                {
                  "type": "chore",
                  "section": "Trivial Changes"
                },
                {
                  "type": "docs",
                  "section": "Trivial Changes"
                },
                {
                  "type": "test",
                  "section": "Tests"
                }
              ]
            }
          }
        ],
        "@semantic-release/changelog",
        [
          "@semantic-release/npm",
          {
            "pkgRoot": "dist"
          }
        ],
        "@semantic-release/github",
        "@semantic-release/git"
      ]
    },
    "browser": {
      ".": "./cjs/car-browser.js",
      "./esm/car.js": "./esm/car-browser.js",
      "./cjs/car.js": "./cjs/car-browser.js",
      "./decoder": "./cjs/lib/decoder.js",
      "./reader": "./cjs/lib/reader-browser.js",
      "./esm/lib/reader.js": "./esm/lib/reader-browser.js",
      "./cjs/lib/reader.js": "./cjs/lib/reader-browser.js",
      "./indexed-reader": "./cjs/lib/indexed-reader-browser.js",
      "./esm/lib/indexed-reader.js": "./esm/lib/indexed-reader-browser.js",
      "./cjs/lib/indexed-reader.js": "./cjs/lib/indexed-reader-browser.js",
      "./indexer": "./cjs/lib/indexer.js",
      "./iterator": "./cjs/lib/iterator.js",
      "./writer": "./cjs/lib/writer-browser.js",
      "./esm/lib/writer.js": "./esm/lib/writer-browser.js",
      "./cjs/lib/writer.js": "./cjs/lib/writer-browser.js"
    },
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-@ipld-car-3.2.4-115951ba2255ec51d865773a074e422c169fb01c-integrity/node_modules/@ipld/car/package.json",
    "readmeFilename": "README.md",
    "readme": "# @ipld/car\n\nA JavaScript Content Addressable aRchive (CAR) file reader and writer.\n\nSee also:\n\n * Original [Go implementation](https://github.com/ipfs/go-car)\n * [CAR specification](https://github.com/ipld/specs/blob/master/block-layer/content-addressable-archives.md)\n * [IPLD](https://ipld.io)\n \n\n## Contents\n\n * [Example](#example)\n * [Usage](#usage)\n * [API](#api)\n * [License](#license)\n\n## Example\n\n```js\n// Create a simple .car file with a single block and that block's CID as the\n// single root. Then read the .car and fetch the block again.\n\nimport fs from 'fs'\nimport { Readable } from 'stream'\nimport { CarReader, CarWriter } from '@ipld/car'\nimport * as raw from 'multiformats/codecs/raw'\nimport { CID } from 'multiformats/cid'\nimport { sha256 } from 'multiformats/hashes/sha2'\n\nasync function example () {\n  const bytes = new TextEncoder().encode('random meaningless bytes')\n  const hash = await sha256.digest(raw.encode(bytes))\n  const cid = CID.create(1, raw.code, hash)\n\n  // create the writer and set the header with a single root\n  const { writer, out } = await CarWriter.create([cid])\n  Readable.from(out).pipe(fs.createWriteStream('example.car'))\n\n  // store a new block, creates a new file entry in the CAR archive\n  await writer.put({ cid, bytes })\n  await writer.close()\n\n  const inStream = fs.createReadStream('example.car')\n  // read and parse the entire stream in one go, this will cache the contents of\n  // the car in memory so is not suitable for large files.\n  const reader = await CarReader.fromIterable(inStream)\n\n  // read the list of roots from the header\n  const roots = await reader.getRoots()\n  // retrieve a block, as a { cid:CID, bytes:UInt8Array } pair from the archive\n  const got = await reader.get(roots[0])\n  // also possible: for await (const { cid, bytes } of CarIterator.fromIterable(inStream)) { ... }\n\n  console.log('Retrieved [%s] from example.car with CID [%s]',\n    new TextDecoder().decode(got.bytes),\n    roots[0].toString())\n}\n\nexample().catch((err) => {\n  console.error(err)\n  process.exit(1)\n})\n```\n\nWill output:\n\n```\nRetrieved [random meaningless bytes] from example.car with CID [bafkreihwkf6mtnjobdqrkiksr7qhp6tiiqywux64aylunbvmfhzeql2coa]\n```\n\nSee the [examples](./examples) directory for more.\n\n## Usage\n\n`@ipld/car` is consumed through factory methods on its different classes. Each\nclass represents a discrete set of functionality. You should select the classes\nthat make the most sense for your use-case.\n\nPlease be aware that `@ipld/car` **does not validate** that block data matches\nthe paired CIDs when reading a CAR. See the\n[verify-car.js](./examples/verify-car.js) example for one possible approach to\nvalidating blocks as they are read. Any CID verification requires that the hash\nfunction that was used to generate the CID be available, the CAR format does\nnot restrict the allowable multihashes.\n\n### [`CarReader`](#CarReader)\n\nThe basic `CarReader` class is consumed via:\n\n```js\nimport { CarReader } from '@ipld/car/reader'\n```\n\nOr alternatively: `import { CarReader } from '@ipld/car'`. CommonJS `require`\nwill also work for the same import paths and references.\n\n`CarReader` is useful for relatively small CAR archives as it buffers the\nentirety of the archive in memory to provide access to its data. This class is\nalso suitable in a browser environment. The `CarReader` class provides\nrandom-access [`get(key)`](#CarReader_get) and  [`has(key)`](#CarReader_has)\nmethods as well as iterators for [`blocks()`](#CarReader_blocks)] and\n[`cids()`](#CarReader_cids)].\n\n`CarReader` can be instantiated from a\n[single `Uint8Array`](#CarReader__fromBytes) or from\n[an `AsyncIterable`](#CarReader__fromIterable) of `Uint8Array`s (note that\nNode.js streams are `AsyncIterable`s and can be consumed in this way).\n\n### [`CarIndexedReader`](#CarIndexedReader)\n\nThe `CarIndexedReader` class is a special form of `CarReader` and can be\nconsumed in **Node.js only** (not in the browser) via:\n\n```js\nimport { CarIndexedReader } from '@ipld/car/indexed-reader'\n```\n\nOr alternatively: `import { CarIndexedReader } from '@ipld/car'`. CommonJS\n`require` will also work for the same import paths and references.\n\nA `CarIndexedReader` provides the same functionality as `CarReader` but is\ninstantiated from [a path to a CAR file](#CarIndexedReader__fromFile) and also\nadds a [`close()`](#CarWriter_close) method that must be called when the reader\nis no longer required, to clean up resources.\n\n`CarIndexedReader` performs a single full-scan of a CAR file, collecting a list\nof `CID`s and their block positions in the archive. It then performs\nrandom-access reads when blocks are requested via `get()` and the `blocks()` and\n`cids()` iterators.\n\nThis class may be sutiable for random-access (primarily via `has()` and `get()`)\nto relatively large CAR files.\n\n### [`CarBlockIterator`](#CarBlockIterator) and [`CarCIDIterator`](#CarCIDIterator)\n\n```js\nimport { CarBlockIterator } from '@ipld/car/iterator'\n// or\nimport { CarCIDIterator } from '@ipld/car/iterator'\n```\n\nOr alternatively:\n`import { CarBlockIterator, CarCIDIterator } from '@ipld/car'`. CommonJS\n`require` will also work for the same import paths and references.\n\nThese two classes provide `AsyncIterable`s to the blocks or just the `CIDs`\ncontained within a CAR archive. These are efficient mechanisms for scanning an\nentire CAR archive, regardless of size, if random-access to blocks is not\nrequired.\n\n`CarBlockIterator` and `CarCIDIterator` can be instantiated from a\nsingle `Uint8Array` (see\n[`CarBlockIterator.fromBytes()`](#CarBlockIterator__fromBytes) and\n[`CarCIDIterator.fromBytes()`](#CarCIDIterator__fromBytes)) or from\nan `AsyncIterable` of `Uint8Array`s (see\n[`CarBlockIterator.fromIterable()`](#CarBlockIterator__fromIterable) and\n[`CarCIDIterator.fromIterable()`](#CarCIDIterator__fromIterable))â€”note that\nNode.js streams are `AsyncIterable`s and can be consumed in this way.\n\n### [`CarIndexer`](#CarIndexer)\n\nThe `CarIndexer` class can be used to scan a CAR archive and provide indexing\ndata on the contents. It can be consumed via:\n\n```js\nimport CarIndexer from '@ipld/car/indexed-reader'\n```\n\nOr alternatively: `import { CarIndexer } from '@ipld/car'`. CommonJS\n`require` will also work for the same import paths and references.\n\nThis class is used within [`CarIndexedReader`](#CarIndexedReader) and is only\nuseful in cases where an external index of a CAR needs to be generated and used.\n\nThe index data can also be used with\n[`CarReader.readRaw()`](#CarReader__readRaw)] to fetch block data directly from\na file descriptor using the index data for that block.\n\n### [`CarWriter`](#CarWriter)\n\nA `CarWriter` is used to create new CAR archives. It can be consumed via:\n\n```js\nimport CarWriter from '@ipld/car/writer'\n```\n\nOr alternatively: `import { CarWriter } from '@ipld/car'`. CommonJS\n`require` will also work for the same import paths and references.\n\n[Creation of a `CarWriter`](#CarWriter__create) involves a \"channel\", or a\n`{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair. The `writer` side\nof the channel is used to [`put()`](#CarWriter_put) blocks, while the `out`\nside of the channel emits the bytes that form the encoded CAR archive.\n\nIn Node.js, you can use the\n[`Readable.from()`](https://nodejs.org/api/stream.html#stream_stream_readable_from_iterable_options)\nAPI to convert the `out` `AsyncIterable` to a standard Node.js stream, or it can\nbe directly fed to a\n[`stream.pipeline()`](https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback).\n\n## API\n\n### Contents\n\n * [`class CarReader`](#CarReader)\n * [`async CarReader#getRoots()`](#CarReader_getRoots)\n * [`async CarReader#has(key)`](#CarReader_has)\n * [`async CarReader#get(key)`](#CarReader_get)\n * [`async * CarReader#blocks()`](#CarReader_blocks)\n * [`async * CarReader#cids()`](#CarReader_cids)\n * [`async CarReader.fromBytes(bytes)`](#CarReader__fromBytes)\n * [`async CarReader.fromIterable(asyncIterable)`](#CarReader__fromIterable)\n * [`async CarReader.readRaw(fd, blockIndex)`](#CarReader__readRaw)\n * [`class CarIndexedReader`](#CarIndexedReader)\n * [`async CarIndexedReader#getRoots()`](#CarIndexedReader_getRoots)\n * [`async CarIndexedReader#has(key)`](#CarIndexedReader_has)\n * [`async CarIndexedReader#get(key)`](#CarIndexedReader_get)\n * [`async * CarIndexedReader#blocks()`](#CarIndexedReader_blocks)\n * [`async * CarIndexedReader#cids()`](#CarIndexedReader_cids)\n * [`async CarIndexedReader#close()`](#CarIndexedReader_close)\n * [`async CarIndexedReader.fromFile(path)`](#CarIndexedReader__fromFile)\n * [`class CarBlockIterator`](#CarBlockIterator)\n * [`async CarBlockIterator#getRoots()`](#CarBlockIterator_getRoots)\n * [`async CarBlockIterator.fromBytes(bytes)`](#CarBlockIterator__fromBytes)\n * [`async CarBlockIterator.fromIterable(asyncIterable)`](#CarBlockIterator__fromIterable)\n * [`class CarCIDIterator`](#CarCIDIterator)\n * [`async CarCIDIterator#getRoots()`](#CarCIDIterator_getRoots)\n * [`async CarCIDIterator.fromBytes(bytes)`](#CarCIDIterator__fromBytes)\n * [`async CarCIDIterator.fromIterable(asyncIterable)`](#CarCIDIterator__fromIterable)\n * [`class CarIndexer`](#CarIndexer)\n * [`async CarIndexer#getRoots()`](#CarIndexer_getRoots)\n * [`async CarIndexer.fromBytes(bytes)`](#CarIndexer__fromBytes)\n * [`async CarIndexer.fromIterable(asyncIterable)`](#CarIndexer__fromIterable)\n * [`class CarWriter`](#CarWriter)\n * [`async CarWriter#put(block)`](#CarWriter_put)\n * [`async CarWriter#close()`](#CarWriter_close)\n * [`async CarWriter.create(roots)`](#CarWriter__create)\n * [`async CarWriter.createAppender()`](#CarWriter__createAppender)\n * [`async CarWriter.updateRootsInBytes(bytes, roots)`](#CarWriter__updateRootsInBytes)\n * [`async CarWriter.updateRootsInFile(fd, roots)`](#CarWriter__updateRootsInFile)\n\n<a name=\"CarReader\"></a>\n### `class CarReader`\n\nProperties:\n\n* `version` `(number)`: The version number of the CAR referenced by this\n  reader (should be `1`).\n\nProvides blockstore-like access to a CAR.\n\nImplements the `RootsReader` interface:\n[`getRoots()`](#CarReader__getRoots). And the `BlockReader` interface:\n[`get()`](#CarReader__get), [`has()`](#CarReader__has),\n[`blocks()`](#CarReader__blocks) (defined as a `BlockIterator`) and\n[`cids()`](#CarReader__cids) (defined as a `CIDIterator`).\n\nLoad this class with either `import { CarReader } from '@ipld/car/reader'`\n(`const { CarReader } = require('@ipld/car/reader')`). Or\n`import { CarReader } from '@ipld/car'` (`const { CarReader } = require('@ipld/car')`).\nThe former will likely result in smaller bundle sizes where this is\nimportant.\n\n<a name=\"CarReader_getRoots\"></a>\n### `async CarReader#getRoots()`\n\n* Returns:  `Promise<CID[]>`\n\nGet the list of roots defined by the CAR referenced by this reader. May be\nzero or more `CID`s.\n\n<a name=\"CarReader_has\"></a>\n### `async CarReader#has(key)`\n\n* `key` `(CID)`\n\n* Returns:  `Promise<boolean>`\n\nCheck whether a given `CID` exists within the CAR referenced by this\nreader.\n\n<a name=\"CarReader_get\"></a>\n### `async CarReader#get(key)`\n\n* `key` `(CID)`\n\n* Returns:  `Promise<(Block|undefined)>`\n\nFetch a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) from the CAR\nreferenced by this reader matching the provided `CID`. In the case where\nthe provided `CID` doesn't exist within the CAR, `undefined` will be\nreturned.\n\n<a name=\"CarReader_blocks\"></a>\n### `async * CarReader#blocks()`\n\n* Returns:  `AsyncGenerator<Block>`\n\nReturns a `BlockIterator` (`AsyncIterable<Block>`) that iterates over all\nof the `Block`s (`{ cid:CID, bytes:Uint8Array }` pairs) contained within\nthe CAR referenced by this reader.\n\n<a name=\"CarReader_cids\"></a>\n### `async * CarReader#cids()`\n\n* Returns:  `AsyncGenerator<CID>`\n\nReturns a `CIDIterator` (`AsyncIterable<CID>`) that iterates over all of\nthe `CID`s contained within the CAR referenced by this reader.\n\n<a name=\"CarReader__fromBytes\"></a>\n### `async CarReader.fromBytes(bytes)`\n\n* `bytes` `(Uint8Array)`\n\n* Returns:  `Promise<CarReader>`: blip blop\n\nInstantiate a [`CarReader`](#CarReader) from a `Uint8Array` blob. This performs a\ndecode fully in memory and maintains the decoded state in memory for full\naccess to the data via the `CarReader` API.\n\n<a name=\"CarReader__fromIterable\"></a>\n### `async CarReader.fromIterable(asyncIterable)`\n\n* `asyncIterable` `(AsyncIterable<Uint8Array>)`\n\n* Returns:  `Promise<CarReader>`\n\nInstantiate a [`CarReader`](#CarReader) from a `AsyncIterable<Uint8Array>`, such as\na [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\nThis performs a decode fully in memory and maintains the decoded state in\nmemory for full access to the data via the `CarReader` API.\n\nCare should be taken for large archives; this API may not be appropriate\nwhere memory is a concern or the archive is potentially larger than the\namount of memory that the runtime can handle.\n\n<a name=\"CarReader__readRaw\"></a>\n### `async CarReader.readRaw(fd, blockIndex)`\n\n* `fd` `(fs.promises.FileHandle|number)`: A file descriptor from the\n  Node.js `fs` module. Either an integer, from `fs.open()` or a `FileHandle`\n  from `fs.promises.open()`.\n* `blockIndex` `(BlockIndex)`: An index pointing to the location of the\n  Block required. This `BlockIndex` should take the form:\n  `{cid:CID, blockLength:number, blockOffset:number}`.\n\n* Returns:  `Promise<Block>`: A `{ cid:CID, bytes:Uint8Array }` pair.\n\nReads a block directly from a file descriptor for an open CAR file. This\nfunction is **only available in Node.js** and not a browser environment.\n\nThis function can be used in connection with [`CarIndexer`](#CarIndexer) which emits\nthe `BlockIndex` objects that are required by this function.\n\nThe user is responsible for opening and closing the file used in this call.\n\n<a name=\"CarIndexedReader\"></a>\n### `class CarIndexedReader`\n\nProperties:\n\n* `version` `(number)`: The version number of the CAR referenced by this\n  reader (should be `1`).\n\nA form of [`CarReader`](#CarReader) that pre-indexes a CAR archive from a file and\nprovides random access to blocks within the file using the index data. This\nfunction is **only available in Node.js** and not a browser environment.\n\nFor large CAR files, using this form of `CarReader` can be singificantly more\nefficient in terms of memory. The index consists of a list of `CID`s and\ntheir location within the archive (see [`CarIndexer`](#CarIndexer)). For large numbers\nof blocks, this index can also occupy a significant amount of memory. In some\ncases it may be necessary to expand the memory capacity of a Node.js instance\nto allow this index to fit. (e.g. by running with\n`NODE_OPTIONS=\"--max-old-space-size=16384\"`).\n\nAs an `CarIndexedReader` instance maintains an open file descriptor for its\nCAR file, an additional [`CarReader#close`](#CarReader_close) method is attached. This\n_must_ be called to have full clean-up of resources after use.\n\nLoad this class with either\n`import { CarIndexedReader } from '@ipld/car/indexed-reader'`\n(`const { CarIndexedReader } = require('@ipld/car/indexed-reader')`). Or\n`import { CarIndexedReader } from '@ipld/car'`\n(`const { CarIndexedReader } = require('@ipld/car')`). The former will likely\nresult in smaller bundle sizes where this is important.\n\n<a name=\"CarIndexedReader_getRoots\"></a>\n### `async CarIndexedReader#getRoots()`\n\n* Returns:  `Promise<CID[]>`\n\nSee [`CarReader#getRoots`](#CarReader_getRoots)\n\n<a name=\"CarIndexedReader_has\"></a>\n### `async CarIndexedReader#has(key)`\n\n* `key` `(CID)`\n\n* Returns:  `Promise<boolean>`\n\nSee [`CarReader#has`](#CarReader_has)\n\n<a name=\"CarIndexedReader_get\"></a>\n### `async CarIndexedReader#get(key)`\n\n* `key` `(CID)`\n\n* Returns:  `Promise<(Block|undefined)>`\n\nSee [`CarReader#get`](#CarReader_get)\n\n<a name=\"CarIndexedReader_blocks\"></a>\n### `async * CarIndexedReader#blocks()`\n\n* Returns:  `AsyncGenerator<Block>`\n\nSee [`CarReader#blocks`](#CarReader_blocks)\n\n<a name=\"CarIndexedReader_cids\"></a>\n### `async * CarIndexedReader#cids()`\n\n* Returns:  `AsyncGenerator<CID>`\n\nSee [`CarReader#cids`](#CarReader_cids)\n\n<a name=\"CarIndexedReader_close\"></a>\n### `async CarIndexedReader#close()`\n\n* Returns:  `Promise<void>`\n\nClose the underlying file descriptor maintained by this `CarIndexedReader`.\nThis must be called for proper resource clean-up to occur.\n\n<a name=\"CarIndexedReader__fromFile\"></a>\n### `async CarIndexedReader.fromFile(path)`\n\n* `path` `(string)`\n\n* Returns:  `Promise<CarIndexedReader>`\n\nInstantiate an [`CarIndexedReader`](#CarIndexedReader) from a file with the provided\n`path`. The CAR file is first indexed with a full path that collects `CID`s\nand block locations. This index is maintained in memory. Subsequent reads\noperate on a read-only file descriptor, fetching the block from its in-file\nlocation.\n\nFor large archives, the initial indexing may take some time. The returned\n`Promise` will resolve only after this is complete.\n\n<a name=\"CarBlockIterator\"></a>\n### `class CarBlockIterator`\n\nProperties:\n\n* `version` `(number)`: The version number of the CAR referenced by this\n  iterator (should be `1`).\n\nProvides an iterator over all of the `Block`s in a CAR. Implements a\n`BlockIterator` interface, or `AsyncIterable<Block>`. Where a `Block` is\na `{ cid:CID, bytes:Uint8Array }` pair.\n\nAs an implementer of `AsyncIterable`, this class can be used directly in a\n`for await (const block of iterator) {}` loop. Where the `iterator` is\nconstructed using [`CarBlockiterator.fromBytes`](#CarBlockiterator__fromBytes) or\n[`CarBlockiterator.fromIterable`](#CarBlockiterator__fromIterable).\n\nAn iteration can only be performce _once_ per instantiation.\n\n`CarBlockIterator` also implements the `RootsReader` interface and provides\nthe [`getRoots()`](#CarBlockiterator__getRoots) method.\n\nLoad this class with either\n`import { CarBlockIterator } from '@ipld/car/iterator'`\n(`const { CarBlockIterator } = require('@ipld/car/iterator')`). Or\n`import { CarBlockIterator } from '@ipld/car'`\n(`const { CarBlockIterator } = require('@ipld/car')`).\n\n<a name=\"CarBlockIterator_getRoots\"></a>\n### `async CarBlockIterator#getRoots()`\n\n* Returns:  `Promise<CID[]>`\n\nGet the list of roots defined by the CAR referenced by this iterator. May be\nzero or more `CID`s.\n\n<a name=\"CarBlockIterator__fromBytes\"></a>\n### `async CarBlockIterator.fromBytes(bytes)`\n\n* `bytes` `(Uint8Array)`\n\n* Returns:  `Promise<CarBlockIterator>`\n\nInstantiate a [`CarBlockIterator`](#CarBlockIterator) from a `Uint8Array` blob. Rather\nthan decoding the entire byte array prior to returning the iterator, as in\n[`CarReader.fromBytes`](#CarReader__fromBytes), only the header is decoded and the remainder\nof the CAR is parsed as the `Block`s as yielded.\n\n<a name=\"CarBlockIterator__fromIterable\"></a>\n### `async CarBlockIterator.fromIterable(asyncIterable)`\n\n* `asyncIterable` `(AsyncIterable<Uint8Array>)`\n\n* Returns:  `Promise<CarBlockIterator>`\n\nInstantiate a [`CarBlockIterator`](#CarBlockIterator) from a `AsyncIterable<Uint8Array>`,\nsuch as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\nRather than decoding the entire byte array prior to returning the iterator,\nas in [`CarReader.fromIterable`](#CarReader__fromIterable), only the header is decoded and the\nremainder of the CAR is parsed as the `Block`s as yielded.\n\n<a name=\"CarCIDIterator\"></a>\n### `class CarCIDIterator`\n\nProperties:\n\n* `version` `(number)`: The version number of the CAR referenced by this\n  iterator (should be `1`).\n\nProvides an iterator over all of the `CID`s in a CAR. Implements a\n`CIDIterator` interface, or `AsyncIterable<CID>`. Similar to\n[`CarBlockIterator`](#CarBlockIterator) but only yields the CIDs in the CAR.\n\nAs an implementer of `AsyncIterable`, this class can be used directly in a\n`for await (const cid of iterator) {}` loop. Where the `iterator` is\nconstructed using [`CarCIDiterator.fromBytes`](#CarCIDiterator__fromBytes) or\n[`CarCIDiterator.fromIterable`](#CarCIDiterator__fromIterable).\n\nAn iteration can only be performce _once_ per instantiation.\n\n`CarCIDIterator` also implements the `RootsReader` interface and provides\nthe [`getRoots()`](#CarCIDiterator__getRoots) method.\n\nLoad this class with either\n`import { CarCIDIterator } from '@ipld/car/iterator'`\n(`const { CarCIDIterator } = require('@ipld/car/iterator')`). Or\n`import { CarCIDIterator } from '@ipld/car'`\n(`const { CarCIDIterator } = require('@ipld/car')`).\n\n<a name=\"CarCIDIterator_getRoots\"></a>\n### `async CarCIDIterator#getRoots()`\n\n* Returns:  `Promise<CID[]>`\n\nGet the list of roots defined by the CAR referenced by this iterator. May be\nzero or more `CID`s.\n\n<a name=\"CarCIDIterator__fromBytes\"></a>\n### `async CarCIDIterator.fromBytes(bytes)`\n\n* `bytes` `(Uint8Array)`\n\n* Returns:  `Promise<CarCIDIterator>`\n\nInstantiate a [`CarCIDIterator`](#CarCIDIterator) from a `Uint8Array` blob. Rather\nthan decoding the entire byte array prior to returning the iterator, as in\n[`CarReader.fromBytes`](#CarReader__fromBytes), only the header is decoded and the remainder\nof the CAR is parsed as the `CID`s as yielded.\n\n<a name=\"CarCIDIterator__fromIterable\"></a>\n### `async CarCIDIterator.fromIterable(asyncIterable)`\n\n* `asyncIterable` `(AsyncIterable<Uint8Array>)`\n\n* Returns:  `Promise<CarCIDIterator>`\n\nInstantiate a [`CarCIDIterator`](#CarCIDIterator) from a `AsyncIterable<Uint8Array>`,\nsuch as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\nRather than decoding the entire byte array prior to returning the iterator,\nas in [`CarReader.fromIterable`](#CarReader__fromIterable), only the header is decoded and the\nremainder of the CAR is parsed as the `CID`s as yielded.\n\n<a name=\"CarIndexer\"></a>\n### `class CarIndexer`\n\nProperties:\n\n* `version` `(number)`: The version number of the CAR referenced by this\n  reader (should be `1`).\n\nProvides an iterator over all of the `Block`s in a CAR, returning their CIDs\nand byte-location information. Implements an `AsyncIterable<BlockIndex>`.\nWhere a `BlockIndex` is a\n`{ cid:CID, length:number, offset:number, blockLength:number, blockOffset:number }`.\n\nAs an implementer of `AsyncIterable`, this class can be used directly in a\n`for await (const blockIndex of iterator) {}` loop. Where the `iterator` is\nconstructed using [`CarIndexer.fromBytes`](#CarIndexer__fromBytes) or\n[`CarIndexer.fromIterable`](#CarIndexer__fromIterable).\n\nAn iteration can only be performce _once_ per instantiation.\n\n`CarIndexer` also implements the `RootsReader` interface and provides\nthe [`getRoots()`](#CarIndexer__getRoots) method.\n\nLoad this class with either\n`import { CarIndexer } from '@ipld/car/indexer'`\n(`const { CarIndexer } = require('@ipld/car/indexer')`). Or\n`import { CarIndexer } from '@ipld/car'`\n(`const { CarIndexer } = require('@ipld/car')`). The former will likely\nresult in smaller bundle sizes where this is important.\n\n<a name=\"CarIndexer_getRoots\"></a>\n### `async CarIndexer#getRoots()`\n\n* Returns:  `Promise<CID[]>`\n\nGet the list of roots defined by the CAR referenced by this indexer. May be\nzero or more `CID`s.\n\n<a name=\"CarIndexer__fromBytes\"></a>\n### `async CarIndexer.fromBytes(bytes)`\n\n* `bytes` `(Uint8Array)`\n\n* Returns:  `Promise<CarIndexer>`\n\nInstantiate a [`CarIndexer`](#CarIndexer) from a `Uint8Array` blob. Only the header\nis decoded initially, the remainder is processed and emitted via the\niterator as it is consumed.\n\n<a name=\"CarIndexer__fromIterable\"></a>\n### `async CarIndexer.fromIterable(asyncIterable)`\n\n* `asyncIterable` `(AsyncIterable<Uint8Array>)`\n\n* Returns:  `Promise<CarIndexer>`\n\nInstantiate a [`CarIndexer`](#CarIndexer) from a `AsyncIterable<Uint8Array>`,\nsuch as a [modern Node.js stream](https://nodejs.org/api/stream.html#stream_streams_compatibility_with_async_generators_and_async_iterators).\nis decoded initially, the remainder is processed and emitted via the\niterator as it is consumed.\n\n<a name=\"CarWriter\"></a>\n### `class CarWriter`\n\nProvides a writer interface for the creation of CAR files.\n\nCreation of a `CarWriter` involves the instatiation of an input / output pair\nin the form of a `WriterChannel`, which is a\n`{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair. These two\ncomponents form what can be thought of as a stream-like interface. The\n`writer` component (an instantiated `CarWriter`), has methods to\n[`put()`](#CarWriter__put) new blocks and [`close()`](#CarWriter__put)\nthe writing operation (finalising the CAR archive). The `out` component is\nan `AsyncIterable` that yields the bytes of the archive. This can be\nredirected to a file or other sink. In Node.js, you can use the\n[`Readable.from()`](https://nodejs.org/api/stream.html#stream_stream_readable_from_iterable_options)\nAPI to convert this to a standard Node.js stream, or it can be directly fed\nto a\n[`stream.pipeline()`](https://nodejs.org/api/stream.html#stream_stream_pipeline_source_transforms_destination_callback).\n\nThe channel will provide a form of backpressure. The `Promise` from a\n`write()` won't resolve until the resulting data is drained from the `out`\niterable.\n\nIt is also possible to ignore the `Promise` from `write()` calls and allow\nthe generated data to queue in memory. This should be avoided for large CAR\narchives of course due to the memory costs and potential for memory overflow.\n\nLoad this class with either\n`import { CarWriter } from '@ipld/car/writer'`\n(`const { CarWriter } = require('@ipld/car/writer')`). Or\n`import { CarWriter } from '@ipld/car'`\n(`const { CarWriter } = require('@ipld/car')`). The former will likely\nresult in smaller bundle sizes where this is important.\n\n<a name=\"CarWriter_put\"></a>\n### `async CarWriter#put(block)`\n\n* `block` `(Block)`: A `{ cid:CID, bytes:Uint8Array }` pair.\n\n* Returns:  `Promise<void>`: The returned promise will only resolve once the\n  bytes this block generates are written to the `out` iterable.\n\nWrite a `Block` (a `{ cid:CID, bytes:Uint8Array }` pair) to the archive.\n\n<a name=\"CarWriter_close\"></a>\n### `async CarWriter#close()`\n\n* Returns:  `Promise<void>`\n\nFinalise the CAR archive and signal that the `out` iterable should end once\nany remaining bytes are written.\n\n<a name=\"CarWriter__create\"></a>\n### `async CarWriter.create(roots)`\n\n* `roots` `(CID[]|CID|void)`\n\n* Returns:  `WriterChannel`: The channel takes the form of\n  `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n\nCreate a new CAR writer \"channel\" which consists of a\n`{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\n\n<a name=\"CarWriter__createAppender\"></a>\n### `async CarWriter.createAppender()`\n\n* Returns:  `WriterChannel`: The channel takes the form of\n  `{ writer:CarWriter, out:AsyncIterable<Uint8Array> }`.\n\nCreate a new CAR appender \"channel\" which consists of a\n`{ writer:CarWriter, out:AsyncIterable<Uint8Array> }` pair.\nThis appender does not consider roots and does not produce a CAR header.\nIt is designed to append blocks to an _existing_ CAR archive. It is\nexpected that `out` will be concatenated onto the end of an existing\narchive that already has a properly formatted header.\n\n<a name=\"CarWriter__updateRootsInBytes\"></a>\n### `async CarWriter.updateRootsInBytes(bytes, roots)`\n\n* `bytes` `(Uint8Array)`\n* `roots` `(CID[])`: A new list of roots to replace the existing list in\n  the CAR header. The new header must take up the same number of bytes as the\n  existing header, so the roots should collectively be the same byte length\n  as the existing roots.\n\n* Returns:  `Promise<Uint8Array>`\n\nUpdate the list of roots in the header of an existing CAR as represented\nin a Uint8Array.\n\nThis operation is an _overwrite_, the total length of the CAR will not be\nmodified. A rejection will occur if the new header will not be the same\nlength as the existing header, in which case the CAR will not be modified.\nIt is the responsibility of the user to ensure that the roots being\nreplaced encode as the same length as the new roots.\n\nThe byte array passed in an argument will be modified and also returned\nupon successful modification.\n\n<a name=\"CarWriter__updateRootsInFile\"></a>\n### `async CarWriter.updateRootsInFile(fd, roots)`\n\n* `fd` `(fs.promises.FileHandle|number)`: A file descriptor from the\n  Node.js `fs` module. Either an integer, from `fs.open()` or a `FileHandle`\n  from `fs.promises.open()`.\n* `roots` `(CID[])`: A new list of roots to replace the existing list in\n  the CAR header. The new header must take up the same number of bytes as the\n  existing header, so the roots should collectively be the same byte length\n  as the existing roots.\n\n* Returns:  `Promise<void>`\n\nUpdate the list of roots in the header of an existing CAR file. The first\nargument must be a file descriptor for CAR file that is open in read and\nwrite mode (not append).\n\nThis operation is an _overwrite_, the total length of the CAR will not be\nmodified. A rejection will occur if the new header will not be the same\nlength as the existing header, in which case the CAR will not be modified.\nIt is the responsibility of the user to ensure that the roots being\nreplaced encode as the same length as the new roots.\n\nThis function is **only available in Node.js** and not a browser\nenvironment.\n\n## License\n\nLicensed under either of\n\n * Apache 2.0, ([LICENSE-APACHE](LICENSE-APACHE) / http://www.apache.org/licenses/LICENSE-2.0)\n * MIT ([LICENSE-MIT](LICENSE-MIT) / http://opensource.org/licenses/MIT)\n\n### Contribution\n\nUnless you explicitly state otherwise, any contribution intentionally submitted for inclusion in the work by you, as defined in the Apache-2.0 license, shall be dual licensed as above, without any additional terms or conditions.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@ipld/car/-/car-3.2.4.tgz#115951ba2255ec51d865773a074e422c169fb01c",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@ipld/car/-/car-3.2.4.tgz",
    "hash": "115951ba2255ec51d865773a074e422c169fb01c",
    "integrity": "sha512-rezKd+jk8AsTGOoJKqzfjLJ3WVft7NZNH95f0pfPbicROvzTyvHCNy567HzSUd6gRXZ9im29z5ZEv9Hw49jSYw==",
    "registry": "npm",
    "packageName": "@ipld/car",
    "cacheIntegrity": "sha512-rezKd+jk8AsTGOoJKqzfjLJ3WVft7NZNH95f0pfPbicROvzTyvHCNy567HzSUd6gRXZ9im29z5ZEv9Hw49jSYw== sha1-EVlRuiJV7FHYZXc6B05CLBafsBw="
  },
  "registry": "npm",
  "hash": "115951ba2255ec51d865773a074e422c169fb01c"
}
{
  "manifest": {
    "name": "@npmcli/arborist",
    "version": "6.2.9",
    "description": "Manage node_modules trees",
    "dependencies": {
      "@isaacs/string-locale-compare": "^1.1.0",
      "@npmcli/fs": "^3.1.0",
      "@npmcli/installed-package-contents": "^2.0.2",
      "@npmcli/map-workspaces": "^3.0.2",
      "@npmcli/metavuln-calculator": "^5.0.0",
      "@npmcli/name-from-folder": "^2.0.0",
      "@npmcli/node-gyp": "^3.0.0",
      "@npmcli/package-json": "^3.0.0",
      "@npmcli/query": "^3.0.0",
      "@npmcli/run-script": "^6.0.0",
      "bin-links": "^4.0.1",
      "cacache": "^17.0.4",
      "common-ancestor-path": "^1.0.1",
      "hosted-git-info": "^6.1.1",
      "json-parse-even-better-errors": "^3.0.0",
      "json-stringify-nice": "^1.1.4",
      "minimatch": "^9.0.0",
      "nopt": "^7.0.0",
      "npm-install-checks": "^6.0.0",
      "npm-package-arg": "^10.1.0",
      "npm-pick-manifest": "^8.0.1",
      "npm-registry-fetch": "^14.0.3",
      "npmlog": "^7.0.1",
      "pacote": "^15.0.8",
      "parse-conflict-json": "^3.0.0",
      "proc-log": "^3.0.0",
      "promise-all-reject-late": "^1.0.0",
      "promise-call-limit": "^1.0.2",
      "read-package-json-fast": "^3.0.2",
      "semver": "^7.3.7",
      "ssri": "^10.0.1",
      "treeverse": "^3.0.0",
      "walk-up-path": "^3.0.1"
    },
    "devDependencies": {
      "@npmcli/eslint-config": "^4.0.0",
      "@npmcli/template-oss": "4.14.1",
      "benchmark": "^2.1.4",
      "chalk": "^4.1.0",
      "minify-registry-metadata": "^3.0.0",
      "nock": "^13.3.0",
      "tap": "^16.3.4",
      "tar-stream": "^3.0.0",
      "tcompare": "^5.0.6"
    },
    "scripts": {
      "test": "tap",
      "posttest": "node ../.. run lint",
      "snap": "tap",
      "test-proxy": "ARBORIST_TEST_PROXY=1 tap --snapshot",
      "lint": "eslint \"**/*.js\"",
      "lintfix": "node ../.. run lint -- --fix",
      "benchmark": "node scripts/benchmark.js",
      "benchclean": "rm -rf scripts/benchmark/*/",
      "postlint": "template-oss-check",
      "template-oss-apply": "template-oss-apply --force"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/npm/cli.git",
      "directory": "workspaces/arborist"
    },
    "author": {
      "name": "GitHub Inc."
    },
    "license": "ISC",
    "files": [
      "bin/",
      "lib/"
    ],
    "main": "lib/index.js",
    "bin": {
      "arborist": "bin/index.js"
    },
    "//": "sk test-env locale to catch locale-specific sorting",
    "tap": {
      "color": true,
      "after": "test/fixtures/cleanup.js",
      "test-env": [
        "NODE_OPTIONS=--no-warnings",
        "LC_ALL=sk"
      ],
      "node-arg": [
        "--no-warnings",
        "--no-deprecation"
      ],
      "timeout": "360",
      "nyc-arg": [
        "--exclude",
        "tap-snapshots/**"
      ]
    },
    "engines": {
      "node": "^14.17.0 || ^16.13.0 || >=18.0.0"
    },
    "templateOSS": {
      "//@npmcli/template-oss": "This file is partially managed by @npmcli/template-oss. Edits may be overwritten.",
      "version": "4.14.1",
      "content": "../../scripts/template-oss/index.js"
    },
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-@npmcli-arborist-6.2.9-9ac892e5444206bd9bb3cb1ff18232322ac0fe54-integrity/node_modules/@npmcli/arborist/package.json",
    "readmeFilename": "README.md",
    "readme": "# @npmcli/arborist\n\n[![npm version](https://img.shields.io/npm/v/@npmcli/arborist.svg)](https://npm.im/@npmcli/arborist)\n[![license](https://img.shields.io/npm/l/@npmcli/arborist.svg)](https://npm.im/@npmcli/arborist)\n[![CI - @npmcli/arborist](https://github.com/npm/cli/actions/workflows/ci-npmcli-arborist.yml/badge.svg)](https://github.com/npm/cli/actions/workflows/ci-npmcli-arborist.yml)\n\nInspect and manage `node_modules` trees.\n\n![a tree with the word ARBORIST superimposed on it](https://raw.githubusercontent.com/npm/arborist/main/docs/logo.svg?sanitize=true)\n\nThere's more documentation [in the docs\nfolder](https://github.com/npm/cli/tree/latest/workspaces/arborist/docs).\n\n## USAGE\n\n```js\nconst Arborist = require('@npmcli/arborist')\n\nconst arb = new Arborist({\n  // options object\n\n  // where we're doing stuff.  defaults to cwd.\n  path: '/path/to/package/root',\n\n  // url to the default registry.  defaults to npm's default registry\n  registry: 'https://registry.npmjs.org',\n\n  // scopes can be mapped to a different registry\n  '@foo:registry': 'https://registry.foo.com/',\n\n  // Auth can be provided in a couple of different ways.  If none are\n  // provided, then requests are anonymous, and private packages will 404.\n  // Arborist doesn't do anything with these, it just passes them down\n  // the chain to pacote and npm-registry-fetch.\n\n  // Safest: a bearer token provided by a registry:\n  // 1. an npm auth token, used with the default registry\n  token: 'deadbeefcafebad',\n  // 2. an alias for the same thing:\n  _authToken: 'deadbeefcafebad',\n\n  // insecure options:\n  // 3. basic auth, username:password, base64 encoded\n  auth: 'aXNhYWNzOm5vdCBteSByZWFsIHBhc3N3b3Jk',\n  // 4. username and base64 encoded password\n  username: 'isaacs',\n  password: 'bm90IG15IHJlYWwgcGFzc3dvcmQ=',\n\n  // auth configs can also be scoped to a given registry with this\n  // rather unusual pattern:\n  '//registry.foo.com:token': 'blahblahblah',\n  '//basic.auth.only.foo.com:_auth': 'aXNhYWNzOm5vdCBteSByZWFsIHBhc3N3b3Jk',\n  '//registry.foo.com:always-auth': true,\n})\n\n// READING\n\n// returns a promise.  reads the actual contents of node_modules\narb.loadActual().then(tree => {\n  // tree is also stored at arb.virtualTree\n})\n\n// read just what the package-lock.json/npm-shrinkwrap says\n// This *also* loads the yarn.lock file, but that's only relevant\n// when building the ideal tree.\narb.loadVirtual().then(tree => {\n  // tree is also stored at arb.virtualTree\n  // now arb.virtualTree is loaded\n  // this fails if there's no package-lock.json or package.json in the folder\n  // note that loading this way should only be done if there's no\n  // node_modules folder\n})\n\n// OPTIMIZING AND DESIGNING\n\n// build an ideal tree from the package.json and various lockfiles.\narb.buildIdealTree(options).then(() => {\n  // next step is to reify that ideal tree onto disk.\n  // options can be:\n  // rm: array of package names to remove at top level\n  // add: Array of package specifiers to add at the top level.  Each of\n  //   these will be resolved with pacote.manifest if the name can't be\n  //   determined from the spec.  (Eg, `github:foo/bar` vs `foo@somespec`.)\n  //   The dep will be saved in the location where it already exists,\n  //   (or pkg.dependencies) unless a different saveType is specified.\n  // saveType: Save added packages in a specific dependency set.\n  //   - null (default) Wherever they exist already, or 'dependencies'\n  //   - prod: definitely in 'dependencies'\n  //   - optional: in 'optionalDependencies'\n  //   - dev: devDependencies\n  //   - peer: save in peerDependencies, and remove any optional flag from\n  //     peerDependenciesMeta if one exists\n  //   - peerOptional: save in peerDependencies, and add a\n  //     peerDepsMeta[name].optional flag\n  // saveBundle: add newly added deps to the bundleDependencies list\n  // update: Either `true` to just go ahead and update everything, or an\n  //   object with any or all of the following fields:\n  //   - all: boolean.  set to true to just update everything\n  //   - names: names of packages update (like `npm update foo`)\n  // prune: boolean, default true.  Prune extraneous nodes from the tree.\n  // preferDedupe: prefer to deduplicate packages if possible, rather than\n  //   choosing a newer version of a dependency.  Defaults to false, ie,\n  //   always try to get the latest and greatest deps.\n  // legacyBundling: Nest every dep under the node requiring it, npm v2 style.\n  //   No unnecessary deduplication.  Default false.\n\n  // At the end of this process, arb.idealTree is set.\n})\n\n// WRITING\n\n// Make the idealTree be the thing that's on disk\narb.reify({\n  // write the lockfile(s) back to disk, and package.json with any updates\n  // defaults to 'true'\n  save: true,\n}).then(() => {\n  // node modules has been written to match the idealTree\n})\n```\n\n## DATA STRUCTURES\n\nA `node_modules` tree is a logical graph of dependencies overlaid on a\nphysical tree of folders.\n\nA `Node` represents a package folder on disk, either at the root of the\npackage, or within a `node_modules` folder.  The physical structure of the\nfolder tree is represented by the `node.parent` reference to the containing\nfolder, and `node.children` map of nodes within its `node_modules`\nfolder, where the key in the map is the name of the folder in\n`node_modules`, and the value is the child node.\n\nA node without a parent is a top of tree.\n\nA `Link` represents a symbolic link to a package on disk.  This can be a\nsymbolic link to a package folder within the current tree, or elsewhere on\ndisk.  The `link.target` is a reference to the actual node.  Links differ\nfrom Nodes in that dependencies are resolved from the _target_ location,\nrather than from the link location.\n\nAn `Edge` represents a dependency relationship.  Each node has an `edgesIn`\nset, and an `edgesOut` map.  Each edge has a `type` which specifies what\nkind of dependency it represents: `'prod'` for regular dependencies,\n`'peer'` for peerDependencies, `'dev'` for devDependencies, and\n`'optional'` for optionalDependencies.  `edge.from` is a reference to the\nnode that has the dependency, and `edge.to` is a reference to the node that\nrequires the dependency.\n\nAs nodes are moved around in the tree, the graph edges are automatically\nupdated to point at the new module resolution targets.  In other words,\n`edge.from`, `edge.name`, and `edge.spec` are immutable; `edge.to` is\nupdated automatically when a node's parent changes.\n\n### class Node\n\nAll arborist trees are `Node` objects.  A `Node` refers\nto a package folder, which may have children in `node_modules`.\n\n* `node.name` The name of this node's folder in `node_modules`.\n* `node.parent` Physical parent node in the tree.  The package in whose\n  `node_modules` folder this package lives.  Null if node is top of tree.\n\n    Setting `node.parent` will automatically update `node.location` and all\n    graph edges affected by the move.\n\n* `node.meta` A `Shrinkwrap` object which looks up `resolved` and\n  `integrity` values for all modules in this tree.  Only relevant on `root`\n  nodes.\n\n* `node.children` Map of packages located in the node's `node_modules`\n  folder.\n* `node.package` The contents of this node's `package.json` file.\n* `node.path` File path to this package.  If the node is a link, then this\n  is the path to the link, not to the link target.  If the node is _not_ a\n  link, then this matches `node.realpath`.\n* `node.realpath` The full real filepath on disk where this node lives.\n* `node.location` A slash-normalized relative path from the root node to\n  this node's path.\n* `node.isLink` Whether this represents a symlink.  Always `false` for Node\n  objects, always `true` for Link objects.\n* `node.isRoot` True if this node is a root node.  (Ie, if `node.root ===\n  node`.)\n* `node.root` The root node where we are working.  If not assigned to some\n  other value, resolves to the node itself.  (Ie, the root node's `root`\n  property refers to itself.)\n* `node.isTop` True if this node is the top of its tree (ie, has no\n  `parent`, false otherwise).\n* `node.top` The top node in this node's tree.  This will be equal to\n  `node.root` for simple trees, but link targets will frequently be outside\n  of (or nested somewhere within) a `node_modules` hierarchy, and so will\n  have a different `top`.\n* `node.dev`, `node.optional`, `node.devOptional`, `node.peer`, Indicators\n  as to whether this node is a dev, optional, and/or peer dependency.\n  These flags are relevant when pruning dependencies out of the tree or\n  deciding what to reify.  See **Package Dependency Flags** below for\n  explanations.\n* `node.edgesOut` Edges in the dependency graph indicating nodes that this\n  node depends on, which resolve its dependencies.\n* `node.edgesIn` Edges in the dependency graph indicating nodes that depend\n  on this node.\n\n* `extraneous` True if this package is not required by any other for any\n  reason.  False for top of tree.\n\n* `node.resolve(name)`  Identify the node that will be returned when code\n  in this package runs `require(name)`\n\n* `node.errors` Array of errors encountered while parsing package.json or\n  version specifiers.\n\n### class Link\n\nLink objects represent a symbolic link within the `node_modules` folder.\nThey have most of the same properties and methods as `Node` objects, with a\nfew differences.\n\n* `link.target` A Node object representing the package that the link\n  references.  If this is a Node already present within the tree, then it\n  will be the same object.  If it's outside of the tree, then it will be\n  treated as the top of its own tree.\n* `link.isLink` Always true.\n* `link.children` This is always an empty map, since links don't have their\n  own children directly.\n\n### class Edge\n\nEdge objects represent a dependency relationship a package node to the\npoint in the tree where the dependency will be loaded.  As nodes are moved\nwithin the tree, Edges automatically update to point to the appropriate\nlocation.\n\n* `new Edge({ from, type, name, spec })`  Creates a new edge with the\n  specified fields.  After instantiation, none of the fields can be\n  changed directly.\n* `edge.from` The node that has the dependency.\n* `edge.type` The type of dependency.  One of `'prod'`, `'dev'`, `'peer'`,\n  or `'optional'`.\n* `edge.name` The name of the dependency.  Ie, the key in the\n  relevant `package.json` dependencies object.\n* `edge.spec` The specifier that is required.  This can be a version,\n  range, tag name, git url, or tarball URL.  Any specifier allowed by npm\n  is supported.\n* `edge.to` Automatically set to the node in the tree that matches the\n  `name` field.\n* `edge.valid` True if `edge.to` satisfies the specifier.\n* `edge.error` A string indicating the type of error if there is a problem,\n  or `null` if it's valid.  Values, in order of precedence:\n    * `DETACHED` Indicates that the edge has been detached from its\n      `edge.from` node, typically because a new edge was created when a\n      dependency specifier was modified.\n    * `MISSING` Indicates that the dependency is unmet.  Note that this is\n      _not_ set for unmet dependencies of the `optional` type.\n    * `PEER LOCAL` Indicates that a `peerDependency` is found in the\n      node's local `node_modules` folder, and the node is not the top of\n      the tree.  This violates the `peerDependency` contract, because it\n      means that the dependency is not a peer.\n    * `INVALID` Indicates that the dependency does not satisfy `edge.spec`.\n* `edge.reload()` Re-resolve to find the appropriate value for `edge.to`.\n  Called automatically from the `Node` class when the tree is mutated.\n\n### Package Dependency Flags\n\nThe dependency type of a node can be determined efficiently by looking at\nthe `dev`, `optional`, and `devOptional` flags on the node object.  These\nare updated by arborist when necessary whenever the tree is modified in\nsuch a way that the dependency graph can change, and are relevant when\npruning nodes from the tree.\n\n```\n| extraneous | peer | dev | optional | devOptional | meaning             | prune?            |\n|------------+------+-----+----------+-------------+---------------------+-------------------|\n|            |      |     |          |             | production dep      | never             |\n|------------+------+-----+----------+-------------+---------------------+-------------------|\n|     X      | N/A  | N/A |   N/A    |     N/A     | nothing depends on  | always            |\n|            |      |     |          |             | this, it is trash   |                   |\n|------------+------+-----+----------+-------------+---------------------+-------------------|\n|            |      |  X  |          |      X      | devDependency, or   | if pruning dev    |\n|            |      |     |          | not in lock | only depended upon  |                   |\n|            |      |     |          |             | by devDependencies  |                   |\n|------------+------+-----+----------+-------------+---------------------+-------------------|\n|            |      |     |    X     |      X      | optionalDependency, | if pruning        |\n|            |      |     |          | not in lock | or only depended on | optional          |\n|            |      |     |          |             | by optionalDeps     |                   |\n|------------+------+-----+----------+-------------+---------------------+-------------------|\n|            |      |  X  |    X     |      X      | Optional dependency | if pruning EITHER |\n|            |      |     |          | not in lock | of dep(s) in the    | dev OR optional   |\n|            |      |     |          |             | dev hierarchy       |                   |\n|------------+------+-----+----------+-------------+---------------------+-------------------|\n|            |      |     |          |      X      | BOTH a non-optional | if pruning BOTH   |\n|            |      |     |          |   in lock   | dep within the dev  | dev AND optional  |\n|            |      |     |          |             | hierarchy, AND a    |                   |\n|            |      |     |          |             | dep within the      |                   |\n|            |      |     |          |             | optional hierarchy  |                   |\n|------------+------+-----+----------+-------------+---------------------+-------------------|\n|            |  X   |     |          |             | peer dependency, or | if pruning peers  |\n|            |      |     |          |             | only depended on by |                   |\n|            |      |     |          |             | peer dependencies   |                   |\n|------------+------+-----+----------+-------------+---------------------+-------------------|\n|            |  X   |  X  |          |      X      | peer dependency of  | if pruning peer   |\n|            |      |     |          | not in lock | dev node hierarchy  | OR dev deps       |\n|------------+------+-----+----------+-------------+---------------------+-------------------|\n|            |  X   |     |    X     |      X      | peer dependency of  | if pruning peer   |\n|            |      |     |          | not in lock | optional nodes, or  | OR optional deps  |\n|            |      |     |          |             | peerOptional dep    |                   |\n|------------+------+-----+----------+-------------+---------------------+-------------------|\n|            |  X   |  X  |    X     |      X      | peer optional deps  | if pruning peer   |\n|            |      |     |          | not in lock | of the dev dep      | OR optional OR    |\n|            |      |     |          |             | hierarchy           | dev               |\n|------------+------+-----+----------+-------------+---------------------+-------------------|\n|            |  X   |     |          |      X      | BOTH a non-optional | if pruning peers  |\n|            |      |     |          |   in lock   | peer dep within the | OR:               |\n|            |      |     |          |             | dev hierarchy, AND  | BOTH optional     |\n|            |      |     |          |             | a peer optional dep | AND dev deps      |\n+------------+------+-----+----------+-------------+---------------------+-------------------+\n```\n\n* If none of these flags are set, then the node is required by the\n  dependency and/or peerDependency hierarchy.  It should not be pruned.\n* If _both_ `node.dev` and `node.optional` are set, then the node is an\n  optional dependency of one of the packages in the devDependency\n  hierarchy.  It should be pruned if _either_ dev or optional deps are\n  being removed.\n* If `node.dev` is set, but `node.optional` is not, then the node is\n  required in the devDependency hierarchy.  It should be pruned if dev\n  dependencies are being removed.\n* If `node.optional` is set, but `node.dev` is not, then the node is\n  required in the optionalDependency hierarchy.  It should be pruned if\n  optional dependencies are being removed.\n* If `node.devOptional` is set, then the node is a (non-optional)\n  dependency within the devDependency hierarchy, _and_ a dependency\n  within the `optionalDependency` hierarchy.  It should be pruned if\n  _both_ dev and optional dependencies are being removed.\n* If `node.peer` is set, then all the same semantics apply as above, except\n  that the dep is brought in by a peer dep at some point, rather than a\n  normal non-peer dependency.\n\nNote: `devOptional` is only set in the shrinkwrap/package-lock file if\n_neither_ `dev` nor `optional` are set, as it would be redundant.\n\n## BIN\n\nArborist ships with a cli that can be used to run arborist specific commands outside of the context of the npm CLI. This script is currently not part of the public API and is subject to breaking changes outside of major version bumps.\n\nTo see the usage run:\n\n```\nnpx @npmcli/arborist --help\n```\n",
    "licenseText": "<!-- This file is automatically added by @npmcli/template-oss. Do not edit. -->\n\nISC License\n\nCopyright npm, Inc.\n\nPermission to use, copy, modify, and/or distribute this\nsoftware for any purpose with or without fee is hereby\ngranted, provided that the above copyright notice and this\npermission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND NPM DISCLAIMS ALL\nWARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO\nEVENT SHALL NPM BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,\nWHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\nTORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE\nUSE OR PERFORMANCE OF THIS SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@npmcli/arborist/-/arborist-6.2.9.tgz#9ac892e5444206bd9bb3cb1ff18232322ac0fe54",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@npmcli/arborist/-/arborist-6.2.9.tgz",
    "hash": "9ac892e5444206bd9bb3cb1ff18232322ac0fe54",
    "integrity": "sha512-uC16dg+aykdctgIYPUKNa3pNGIDYh1egzk5vOf34d24cw5mwMsVArFiVdcRieKHmOGEv595se3x0fvbwNrBk8g==",
    "registry": "npm",
    "packageName": "@npmcli/arborist",
    "cacheIntegrity": "sha512-uC16dg+aykdctgIYPUKNa3pNGIDYh1egzk5vOf34d24cw5mwMsVArFiVdcRieKHmOGEv595se3x0fvbwNrBk8g== sha1-msiS5URCBr2bs8sf8YIyMirA/lQ="
  },
  "registry": "npm",
  "hash": "9ac892e5444206bd9bb3cb1ff18232322ac0fe54"
}
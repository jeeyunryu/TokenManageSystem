{
  "manifest": {
    "name": "varint",
    "version": "5.0.2",
    "description": "protobuf-style varint bytes - use msb to create integer values of varying sizes",
    "main": "index.js",
    "scripts": {
      "test": "node test.js"
    },
    "repository": {
      "type": "git",
      "url": "git://github.com/chrisdickinson/varint.git"
    },
    "keywords": [
      "varint",
      "protobuf",
      "encode",
      "decode"
    ],
    "author": {
      "name": "Chris Dickinson",
      "email": "chris@neversaw.us"
    },
    "license": "MIT",
    "devDependencies": {
      "tape": "~2.12.3"
    },
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-varint-5.0.2-5b47f8a947eb668b848e034dcfa87d0ff8a7f7a4-integrity/node_modules/varint/package.json",
    "readmeFilename": "README.md",
    "readme": "# varint\n\nencode whole numbers to an array of [protobuf-style varint bytes](https://developers.google.com/protocol-buffers/docs/encoding#varints) and also decode them.\n\n```javascript\nvar varint = require('varint')\n\nvar bytes = varint.encode(300) // === [0xAC, 0x02]\nvarint.decode(bytes) // 300\nvarint.decode.bytes // 2 (the last decode() call required 2 bytes)\n```\n\n## api\n\n### varint = require('varint')\n\n### varint.encode(num[, buffer=[], offset=0]) -> buffer\n\nEncodes `num` into `buffer` starting at `offset`. returns `buffer`, with the encoded varint written into it. If `buffer` is not provided, it will default to a new array.\n\n`varint.encode.bytes` will now be set to the number of bytes\nmodified.\n\n### varint.decode(data[, offset=0]) -> number\n\ndecodes `data`, which can be either a buffer or array of integers, from position `offset` or default 0 and returns the decoded original integer.\n\nThrows a `RangeError` when `data` does not represent a valid encoding.\n\n### varint.decode.bytes\n\nif you also require the length (number of bytes) that were required to decode the integer you can access it via `varint.decode.bytes`. this is an integer property that will tell you the number of bytes that the last .decode() call had to use to decode.\n\n### varint.encode.bytes\n\nsimilar to `decode.bytes` when encoding a number it can be useful to know how many bytes where written (especially if you pass an output array). you can access this via `varint.encode.bytes` which holds the number of bytes written in the last encode.\n\n\n### varint.encodingLength(num)\n\nreturns the number of bytes this number will be encoded as, up to a maximum of 8.\n\n## usage notes\n\nIf varint is passed a buffer that does not contain a valid end\nbyte, then `decode` will throw `RangeError`, and `decode.bytes` \nwill be set to 0. If you are reading from a streaming source,\nit's okay to pass an incomplete buffer into `decode`, detect this\ncase, and then concatenate the next buffer.\n\n# License\n\nMIT\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/varint/-/varint-5.0.2.tgz#5b47f8a947eb668b848e034dcfa87d0ff8a7f7a4",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/varint/-/varint-5.0.2.tgz",
    "hash": "5b47f8a947eb668b848e034dcfa87d0ff8a7f7a4",
    "integrity": "sha512-lKxKYG6H03yCZUpAGOPOsMcGxd1RHCu1iKvEHYDPmTyq2HueGhD73ssNBqqQWfvYs04G9iUFRvmAVLW20Jw6ow==",
    "registry": "npm",
    "packageName": "varint",
    "cacheIntegrity": "sha512-lKxKYG6H03yCZUpAGOPOsMcGxd1RHCu1iKvEHYDPmTyq2HueGhD73ssNBqqQWfvYs04G9iUFRvmAVLW20Jw6ow== sha1-W0f4qUfrZouEjgNNz6h9D/in96Q="
  },
  "registry": "npm",
  "hash": "5b47f8a947eb668b848e034dcfa87d0ff8a7f7a4"
}
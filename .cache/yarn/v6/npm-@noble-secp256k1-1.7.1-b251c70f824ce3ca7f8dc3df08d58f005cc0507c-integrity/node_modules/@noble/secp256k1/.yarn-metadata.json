{
  "manifest": {
    "name": "@noble/secp256k1",
    "version": "1.7.1",
    "description": "Fastest JS implementation of secp256k1. Independently audited, high-security, 0-dependency ECDSA & Schnorr signatures",
    "files": [
      "lib"
    ],
    "main": "lib/index.js",
    "module": "lib/esm/index.js",
    "types": "lib/index.d.ts",
    "scripts": {
      "build": "tsc && tsc -p tsconfig.esm.json",
      "build:release": "rollup -c rollup.config.js",
      "lint": "prettier --print-width 100 --single-quote --check index.ts",
      "format": "prettier --print-width 100 --single-quote --write index.ts",
      "test": "jest",
      "coverage": "jest --coverage",
      "bench": "node test/benchmark.js"
    },
    "author": {
      "name": "Paul Miller",
      "url": "https://paulmillr.com"
    },
    "homepage": "https://paulmillr.com/noble/",
    "repository": {
      "type": "git",
      "url": "https://github.com/paulmillr/noble-secp256k1.git"
    },
    "license": "MIT",
    "browser": {
      "crypto": false
    },
    "devDependencies": {
      "@noble/hashes": "1.1.2",
      "@rollup/plugin-commonjs": "22.0.0",
      "@rollup/plugin-node-resolve": "13.3.0",
      "@types/jest": "28.1.1",
      "@types/node": "17.0.18",
      "fast-check": "3.0.0",
      "jest": "28.1.0",
      "micro-bmark": "0.2.0",
      "prettier": "2.6.2",
      "rollup": "2.75.5",
      "ts-jest": "28.0.4",
      "typescript": "4.7.3"
    },
    "keywords": [
      "secp256k1",
      "secp",
      "secp256",
      "elliptic",
      "elliptic curve",
      "curve",
      "signature",
      "ecc",
      "rfc6979",
      "schnorr",
      "sig",
      "bip0340",
      "bip340",
      "ecdsa",
      "endomorphism",
      "cryptography",
      "security",
      "noble"
    ],
    "exports": {
      ".": {
        "types": "./lib/index.d.ts",
        "import": "./lib/esm/index.js",
        "default": "./lib/index.js"
      }
    },
    "jest": {
      "testRegex": "/test/.*?\\.ts",
      "transform": {
        "^.+\\.ts$": "ts-jest"
      }
    },
    "funding": [
      {
        "type": "individual",
        "url": "https://paulmillr.com/funding/"
      }
    ],
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-@noble-secp256k1-1.7.1-b251c70f824ce3ca7f8dc3df08d58f005cc0507c-integrity/node_modules/@noble/secp256k1/package.json",
    "readmeFilename": "README.md",
    "readme": "# noble-secp256k1 ![Node CI](https://github.com/paulmillr/noble-secp256k1/workflows/Node%20CI/badge.svg) [![code style: prettier](https://img.shields.io/badge/code_style-prettier-ff69b4.svg?style=flat-square)](https://github.com/prettier/prettier)\n\n[Fastest](#speed) JS implementation of [secp256k1](https://www.secg.org/sec2-v2.pdf),\nan elliptic curve that could be used for asymmetric encryption,\nECDH key agreement protocol and signature schemes. Supports deterministic **ECDSA** from RFC6979 and **Schnorr** signatures from [BIP0340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki).\n\n[**Audited**](#security) by an independent security firm. Check out [the online demo](https://paulmillr.com/ecc) and blog post: [Learning fast elliptic-curve cryptography in JS](https://paulmillr.com/posts/noble-secp256k1-fast-ecc/)\n\n### This library belongs to _noble_ crypto\n\n> **noble-crypto** — high-security, easily auditable set of contained cryptographic libraries and tools.\n\n- No dependencies, one small file\n- Easily auditable TypeScript/JS code\n- Supported in all major browsers and stable node.js versions\n- All releases are signed with PGP keys\n- Check out [homepage](https://paulmillr.com/noble/) & all libraries:\n  [secp256k1](https://github.com/paulmillr/noble-secp256k1),\n  [ed25519](https://github.com/paulmillr/noble-ed25519),\n  [bls12-381](https://github.com/paulmillr/noble-bls12-381),\n  [hashes](https://github.com/paulmillr/noble-hashes)\n\n## Usage\n\nUse NPM in node.js / browser, or include single file from\n[GitHub's releases page](https://github.com/paulmillr/noble-secp256k1/releases):\n\n> npm install @noble/secp256k1\n\n```js\n// Common.js and ECMAScript Modules (ESM)\nimport * as secp from '@noble/secp256k1';\n// If you're using single file, use global variable instead: `window.nobleSecp256k1`\n\n// Supports both async and sync methods, see docs\n(async () => {\n  // keys, messages & other inputs can be Uint8Arrays or hex strings\n  // Uint8Array.from([0xde, 0xad, 0xbe, 0xef]) === 'deadbeef'\n  const privKey = secp.utils.randomPrivateKey();\n  const pubKey = secp.getPublicKey(privKey);\n  const msgHash = await secp.utils.sha256('hello world');\n  const signature = await secp.sign(msgHash, privKey);\n  const isValid = secp.verify(signature, msgHash, pubKey);\n\n  // Schnorr signatures\n  const rpub = secp.schnorr.getPublicKey(privKey);\n  const rsignature = await secp.schnorr.sign(message, privKey);\n  const risValid = await secp.schnorr.verify(rsignature, message, rpub);\n})();\n```\n\nTo use the module with [Deno](https://deno.land),\nyou will need [import map](https://deno.land/manual/linking_to_external_code/import_maps):\n\n- `deno run --import-map=imports.json app.ts`\n- app.ts: `import * as secp from \"https://deno.land/x/secp256k1/mod.ts\";`\n- imports.json: `{\"imports\": {\"crypto\": \"https://deno.land/std@0.153.0/node/crypto.ts\"}}`\n\n## API\n\n- [`getPublicKey(privateKey)`](#getpublickeyprivatekey)\n- [`sign(msgHash, privateKey)`](#signmsghash-privatekey)\n- [`verify(signature, msgHash, publicKey)`](#verifysignature-msghash-publickey)\n- [`getSharedSecret(privateKeyA, publicKeyB)`](#getsharedsecretprivatekeya-publickeyb)\n- [`recoverPublicKey(hash, signature, recovery)`](#recoverpublickeyhash-signature-recovery)\n- [`schnorr.getPublicKey(privateKey)`](#schnorrgetpublickeyprivatekey)\n- [`schnorr.sign(message, privateKey)`](#schnorrsignmessage-privatekey)\n- [`schnorr.verify(signature, message, publicKey)`](#schnorrverifysignature-message-publickey)\n- [Utilities](#utilities)\n\n##### `getPublicKey(privateKey)`\n\n```typescript\nfunction getPublicKey(privateKey: Uint8Array | string | bigint, isCompressed = false): Uint8Array;\n```\n\nCreates public key for the corresponding private key. The default is full 65-byte key.\n\n- `isCompressed = false` determines whether to return compact (33-byte), or full (65-byte) key.\n\nInternally, it does `Point.BASE.multiply(privateKey)`. If you need actual `Point` instead of\n`Uint8Array`, use `Point.fromPrivateKey(privateKey)`.\n\n##### `sign(msgHash, privateKey)`\n\n```typescript\nfunction sign(\n  msgHash: Uint8Array | string,\n  privateKey: Uint8Array | string,\n  opts?: Options\n): Promise<Uint8Array>;\nfunction sign(\n  msgHash: Uint8Array | string,\n  privateKey: Uint8Array | string,\n  opts?: Options\n): Promise<[Uint8Array, number]>;\n```\n\nGenerates low-s deterministic ECDSA signature as per RFC6979.\n\n- `msgHash: Uint8Array | string` - 32-byte message hash which would be signed\n- `privateKey: Uint8Array | string | bigint` - private key which will sign the hash\n- `options?: Options` - _optional_ object related to signature value and format with following keys:\n  - `recovered: boolean = false` - whether the recovered bit should be included in the result. In this case, the result would be an array of two items.\n  - `canonical: boolean = true` - whether a signature `s` should be no more than 1/2 prime order.\n    `true` (default) makes signatures compatible with libsecp256k1,\n    `false` makes signatures compatible with openssl\n  - `der: boolean = true` - whether the returned signature should be in DER format. If `false`, it would be in Compact format (32-byte r + 32-byte s)\n  - `extraEntropy: Uint8Array | string | true` - additional entropy `k'` for deterministic signature, follows section 3.6 of RFC6979. When `true`, it would automatically be filled with 32 bytes of cryptographically secure entropy. **Strongly recommended** to pass `true` to improve security:\n    - Schnorr signatures are doing it every time\n    - It would help a lot in case there is an error somewhere in `k` generation. Exposing `k` could leak private keys\n    - If the entropy generator is broken, signatures would be the same as they are without the option\n    - Signatures with extra entropy would have different `r` / `s`, which means they\n      would still be valid, but may break some test vectors if you're cross-testing against other libs\n\nThe function is asynchronous because we're utilizing built-in HMAC API to not rely on dependencies.\n\n```ts\n(async () => {\n  // Signatures with improved security\n  const signatureE = await secp.sign(msgHash, privKey, { extraEntropy: true });\n  // Malleable signatures, but compatible with openssl\n  const signatureM = await secp.sign(msgHash, privKey, { canonical: false });\n})();\n```\n\n```typescript\nfunction signSync(\n  msgHash: Uint8Array | string,\n  privateKey: Uint8Array | string,\n  opts?: Options\n): Uint8Array | [Uint8Array, number];\n```\n\n`signSync` counterpart could also be used, you need to set `utils.hmacSha256Sync` to a function with signature `key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array`. Example with `noble-hashes` package:\n\n```ts\nimport { hmac } from '@noble/hashes/hmac';\nimport { sha256 } from '@noble/hashes/sha256';\nsecp256k1.utils.hmacSha256Sync = (key, ...msgs) => hmac(sha256, key, secp256k1.utils.concatBytes(...msgs))\nsecp256k1.utils.sha256Sync = (...msgs) => sha256(secp256k1.utils.concatBytes(...msgs))\n// Can be used now\nsecp256k1.signSync(msgHash, privateKey);\nschnorr.signSync(message, privateKey)\n```\n\n##### `verify(signature, msgHash, publicKey)`\n\n```typescript\nfunction verify(\n  signature: Uint8Array | string,\n  msgHash: Uint8Array | string,\n  publicKey: Uint8Array | string\n): boolean;\nfunction verify(signature: Signature, msgHash: Uint8Array | string, publicKey: Point): boolean;\n```\n\n- `signature: Uint8Array | string | { r: bigint, s: bigint }` - object returned by the `sign` function\n- `msgHash: Uint8Array | string` - message hash that needs to be verified\n- `publicKey: Uint8Array | string | Point` - e.g. that was generated from `privateKey` by `getPublicKey`\n- `options?: Options` - _optional_ object related to signature value and format\n  - `strict: boolean = true` - whether a signature `s` should be no more than 1/2 prime order.\n    `true` (default) makes signatures compatible with libsecp256k1,\n    `false` makes signatures compatible with openssl\n- Returns `boolean`: `true` if `signature == hash`; otherwise `false`\n\n##### `getSharedSecret(privateKeyA, publicKeyB)`\n\n```typescript\nfunction getSharedSecret(\n  privateKeyA: Uint8Array | string | bigint,\n  publicKeyB: Uint8Array | string | Point,\n  isCompressed = false\n): Uint8Array;\n```\n\nComputes ECDH (Elliptic Curve Diffie-Hellman) shared secret between a private key and a different public key.\n\n- To get Point instance, use `Point.fromHex(publicKeyB).multiply(privateKeyA)`\n- `isCompressed = false` determines whether to return compact (33-byte), or full (65-byte) key\n- If you have one public key you'll be creating lots of secrets against,\n  consider massive speed-up by using precomputations:\n\n  ```js\n  const pub = secp.utils.precompute(8, publicKeyB);\n  // Use pub everywhere instead of publicKeyB\n  getSharedSecret(privKey, pub); // Now 12x faster\n  ```\n\n##### `recoverPublicKey(hash, signature, recovery)`\n\n```typescript\nfunction recoverPublicKey(\n  msgHash: Uint8Array | string,\n  signature: Uint8Array | string,\n  recovery: number,\n  isCompressed = false\n): Uint8Array | undefined;\n```\n\nRecovers public key from message hash, signature & recovery bit. The default is full 65-byte key.\n\n- `msgHash: Uint8Array | string` - message hash which would be signed\n- `signature: Uint8Array | string | { r: bigint, s: bigint }` - object returned by the `sign` function\n- `recovery: number` - recovery bit returned by `sign` with `recovered` option\n- `isCompressed = false` determines whether to return compact (33-byte), or full (65-byte) key\n\nPublic key is generated by doing scalar multiplication of a base Point(x, y) by a fixed\ninteger. The result is another `Point(x, y)` which we will by default encode to hex Uint8Array.\nIf signature is invalid - function will return `undefined` as result.\nTo get Point instance, use `Point.fromSignature(hash, signature, recovery)`.\n\n##### `schnorr.getPublicKey(privateKey)`\n\n```typescript\nfunction schnorrGetPublicKey(privateKey: Uint8Array | string): Uint8Array;\n```\n\nCalculates 32-byte public key from a private key.\n\n_Warning:_ it is incompatible with non-schnorr pubkey. Specifically, its _y_ coordinate may be flipped. See [BIP340](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) for clarification.\n\n##### `schnorr.sign(message, privateKey)`\n\n```typescript\nfunction schnorrSign(\n  message: Uint8Array | string,\n  privateKey: Uint8Array | string,\n  auxilaryRandom?: Uint8Array\n): Promise<Uint8Array>;\n```\n\nGenerates Schnorr signature as per BIP0340. Asynchronous, so use `await`.\n\n- `message: Uint8Array | string` - message (not hash) which would be signed\n- `privateKey: Uint8Array | string | bigint` - private key which will sign the hash\n- `auxilaryRandom?: Uint8Array` — optional 32 random bytes. By default, the method gathers cryptogarphically secure entropy\n- Returns Schnorr signature in Hex format.\n\n##### `schnorr.verify(signature, message, publicKey)`\n\n```typescript\nfunction schnorrVerify(\n  signature: Uint8Array | string,\n  message: Uint8Array | string,\n  publicKey: Uint8Array | string\n): boolean;\n```\n\n- `signature: Uint8Array | string | { r: bigint, s: bigint }` - object returned by the `sign` function\n- `message: Uint8Array | string` - message (not hash) that needs to be verified\n- `publicKey: Uint8Array | string | Point` - e.g. that was generated from `privateKey` by `getPublicKey`\n- Returns `boolean`: `true` if `signature == hash`; otherwise `false`\n\n#### Utilities\n\nsecp256k1 exposes a few internal utilities for improved developer experience.\n\n```js\n// Default output is Uint8Array. If you need hex string as an output:\nconsole.log(secp.utils.bytesToHex(pubKey));\n```\n\n```typescript\nconst utils: {\n  // Can take 40 or more bytes of uniform input e.g. from CSPRNG or KDF\n  // and convert them into private key, with the modulo bias being neglible.\n  // As per FIPS 186 B.1.1.\n  hashToPrivateKey: (hash: Hex) => Uint8Array;\n  // Returns `Uint8Array` of 32 cryptographically secure random bytes that can be used as private key\n  randomPrivateKey: () => Uint8Array;\n  // Checks private key for validity\n  isValidPrivateKey(privateKey: PrivKey): boolean;\n\n  // Returns `Uint8Array` of x cryptographically secure random bytes.\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  // Converts Uint8Array to hex string\n  bytesToHex(uint8a: Uint8Array): string;\n  hexToBytes(hex: string): Uint8Array;\n  concatBytes(...arrays: Uint8Array[]): Uint8Array;\n  // Modular division over curve prime\n  mod: (number: number | bigint, modulo = CURVE.P): bigint;\n  // Modular inversion\n  invert(number: bigint, modulo?: bigint): bigint;\n\n  sha256: (message: Uint8Array) => Promise<Uint8Array>;\n  hmacSha256: (key: Uint8Array, ...messages: Uint8Array[]) => Promise<Uint8Array>;\n\n  // You can set up your synchronous methods for `signSync`/`signSchnorrSync` to work.\n  // The argument order is identical to async methods from above\n  sha256Sync: undefined;\n  hmacSha256Sync: undefined;\n\n  // BIP0340-style tagged hashes\n  taggedHash: (tag: string, ...messages: Uint8Array[]) => Promise<Uint8Array>;\n  taggedHashSync: (tag: string, ...messages: Uint8Array[]) => Uint8Array;\n\n  // 1. Returns cached point which you can use to pass to `getSharedSecret` or to `#multiply` by it.\n  // 2. Precomputes point multiplication table. Is done by default on first `getPublicKey()` call.\n  // If you want your first getPublicKey to take 0.16ms instead of 20ms, make sure to call\n  // utils.precompute() somewhere without arguments first.\n  precompute(windowSize?: number, point?: Point): Point;\n};\n\nsecp256k1.CURVE.P // Field, 2 ** 256 - 2 ** 32 - 977\nsecp256k1.CURVE.n // Order, 2 ** 256 - 432420386565659656852420866394968145599\nsecp256k1.Point.BASE // new secp256k1.Point(Gx, Gy) where\n// Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240n\n// Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424n;\n\n// Elliptic curve point in Affine (x, y) coordinates.\nsecp256k1.Point {\n  constructor(x: bigint, y: bigint);\n  // Supports compressed and non-compressed hex\n  static fromHex(hex: Uint8Array | string);\n  static fromPrivateKey(privateKey: Uint8Array | string | number | bigint);\n  static fromSignature(\n    msgHash: Hex,\n    signature: Signature,\n    recovery: number | bigint\n  ): Point | undefined {\n  toRawBytes(isCompressed = false): Uint8Array;\n  toHex(isCompressed = false): string;\n  equals(other: Point): boolean;\n  negate(): Point;\n  add(other: Point): Point;\n  subtract(other: Point): Point;\n  // Constant-time scalar multiplication.\n  multiply(scalar: bigint | Uint8Array): Point;\n}\nsecp256k1.Signature {\n  constructor(r: bigint, s: bigint);\n  // DER encoded ECDSA signature\n  static fromDER(hex: Uint8Array | string);\n  // R, S 32-byte each\n  static fromCompact(hex: Uint8Array | string);\n  assertValidity(): void;\n  hasHighS(): boolean; // high-S sigs cannot be produced using { canonical: true }\n  toDERRawBytes(): Uint8Array;\n  toDERHex(): string;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n}\n```\n\n## Security\n\nNoble is production-ready.\n\n1. The library has been audited by an independent security firm cure53: [PDF](https://cure53.de/pentest-report_noble-lib.pdf). See [changes since audit](https://github.com/paulmillr/noble-secp256k1/compare/1.2.0..main).\n   - The audit has been [crowdfunded](https://gitcoin.co/grants/2451/audit-of-noble-secp256k1-cryptographic-library) by community with help of [Umbra.cash](https://umbra.cash).\n2. The library has also been fuzzed by [Guido Vranken's cryptofuzz](https://github.com/guidovranken/cryptofuzz). You can run the fuzzer by yourself to check it.\n\nWe're using built-in JS `BigInt`, which is potentially vulnerable to [timing attacks](https://en.wikipedia.org/wiki/Timing_attack) as [per official spec](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt#cryptography). But, _JIT-compiler_ and _Garbage Collector_ make \"constant time\" extremely hard to achieve in a scripting language. Which means _any other JS library doesn't use constant-time bigints_. Including bn.js or anything else. Even statically typed Rust, a language without GC, [makes it harder to achieve constant-time](https://www.chosenplaintext.ca/open-source/rust-timing-shield/security) for some cases. If your goal is absolute security, don't use any JS lib — including bindings to native ones. Use low-level libraries & languages. Nonetheless we've hardened implementation of ec curve multiplication to be algorithmically constant time.\n\nWe however consider infrastructure attacks like rogue NPM modules very important; that's why it's crucial to minimize the amount of 3rd-party dependencies & native bindings. If your app uses 500 dependencies, any dep could get hacked and you'll be downloading malware with every `npm install`. Our goal is to minimize this attack vector.\n\n## Speed\n\nBenchmarks measured with Apple M2 on MacOS 12 with node.js 18.8.\n\n    getPublicKey(utils.randomPrivateKey()) x 7,093 ops/sec @ 140μs/op\n    sign x 5,615 ops/sec @ 178μs/op\n    signSync (@noble/hashes) x 5,209 ops/sec @ 191μs/op\n    verify x 1,114 ops/sec @ 896μs/op\n    recoverPublicKey x 1,018 ops/sec @ 982μs/op\n    getSharedSecret aka ecdh x 665 ops/sec @ 1ms/op\n    getSharedSecret (precomputed) x 7,426 ops/sec @ 134μs/op\n    Point.fromHex (decompression) x 14,582 ops/sec @ 68μs/op\n    schnorr.sign x 805 ops/sec @ 1ms/op\n    schnorr.verify x 1,129 ops/sec @ 885μs/op\n\nCompare to other libraries on M1 (`openssl` uses native bindings, not JS):\n\n    elliptic#getPublicKey x 1,940 ops/sec\n    sjcl#getPublicKey x 211 ops/sec\n\n    elliptic#sign x 1,808 ops/sec\n    sjcl#sign x 199 ops/sec\n    openssl#sign x 4,243 ops/sec\n    ecdsa#sign x 116 ops/sec\n    bip-schnorr#sign x 60 ops/sec\n\n    elliptic#verify x 812 ops/sec\n    sjcl#verify x 166 ops/sec\n    openssl#verify x 4,452 ops/sec\n    ecdsa#verify x 80 ops/sec\n    bip-schnorr#verify x 56 ops/sec\n\n    elliptic#ecdh x 971 ops/sec\n\n## Contributing\n\nCheck out a blog post about this library: [Learning fast elliptic-curve cryptography in JS](https://paulmillr.com/posts/noble-secp256k1-fast-ecc/).\n\n1. Clone the repository.\n2. `npm install` to install build dependencies like TypeScript\n3. `npm run build` to compile TypeScript code\n4. `npm test` to run jest on `test/index.ts`\n\nSpecial thanks to [Roman Koblov](https://github.com/romankoblov), who have helped to improve scalar multiplication speed.\n\n## License\n\nMIT (c) Paul Miller [(https://paulmillr.com)](https://paulmillr.com), see LICENSE file.\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2019 Paul Miller (https://paulmillr.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the “Software”), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE."
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@noble/secp256k1/-/secp256k1-1.7.1.tgz#b251c70f824ce3ca7f8dc3df08d58f005cc0507c",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@noble/secp256k1/-/secp256k1-1.7.1.tgz",
    "hash": "b251c70f824ce3ca7f8dc3df08d58f005cc0507c",
    "integrity": "sha512-hOUk6AyBFmqVrv7k5WAw/LpszxVbj9gGN4JRkIX52fdFAj1UA61KXmZDvqVEm+pOyec3+fIeZB02LYa/pWOArw==",
    "registry": "npm",
    "packageName": "@noble/secp256k1",
    "cacheIntegrity": "sha512-hOUk6AyBFmqVrv7k5WAw/LpszxVbj9gGN4JRkIX52fdFAj1UA61KXmZDvqVEm+pOyec3+fIeZB02LYa/pWOArw== sha1-slHHD4JM48p/jcPfCNWPAFzAUHw="
  },
  "registry": "npm",
  "hash": "b251c70f824ce3ca7f8dc3df08d58f005cc0507c"
}
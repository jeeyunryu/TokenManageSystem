{
  "manifest": {
    "name": "@truffle/contract",
    "description": "A better contract abstraction for Ethereum (formerly EtherPudding)",
    "license": "MIT",
    "author": {
      "name": "Tim Coulter",
      "email": "tim@trufflesuite.com"
    },
    "homepage": "https://github.com/trufflesuite/truffle/tree/master/packages/contract#readme",
    "repository": {
      "type": "git",
      "url": "https://github.com/trufflesuite/truffle.git",
      "directory": "packages/contract"
    },
    "bugs": {
      "url": "https://github.com/trufflesuite/truffle/issues"
    },
    "version": "4.6.20",
    "main": "index.js",
    "scripts": {
      "build": "yarn compile",
      "compile": "NODE_ENV=production webpack --config ./webpack.config.js && NODE_ENV=development webpack --config ./webpack.config.js",
      "prepare": "yarn compile",
      "publish:next": "node ../truffle/scripts/prereleaseVersion.js next next"
    },
    "dependencies": {
      "@ensdomains/ensjs": "^2.1.0",
      "@truffle/blockchain-utils": "^0.1.7",
      "@truffle/contract-schema": "^3.4.13",
      "@truffle/debug-utils": "^6.0.48",
      "@truffle/error": "^0.2.0",
      "@truffle/interface-adapter": "^0.5.32",
      "bignumber.js": "^7.2.1",
      "debug": "^4.3.1",
      "ethers": "^4.0.32",
      "web3": "1.8.2",
      "web3-core-helpers": "1.8.2",
      "web3-core-promievent": "1.8.2",
      "web3-eth-abi": "1.8.2",
      "web3-utils": "1.8.2"
    },
    "devDependencies": {
      "assert": "^2.0.0",
      "buffer": "6.0.3",
      "crypto-browserify": "^3.12.0",
      "https-browserify": "^1.0.0",
      "os-browserify": "^0.3.0",
      "path-browserify": "^1.0.1",
      "stream-browserify": "^3.0.0",
      "stream-http": "^3.2.0",
      "url": "^0.11.0",
      "vm-browserify": "^1.1.2",
      "webpack": "^5.73.0",
      "webpack-cli": "^4.10.0"
    },
    "keywords": [
      "abstraction",
      "contract",
      "ethereum",
      "truffle"
    ],
    "publishConfig": {
      "access": "public"
    },
    "gitHead": "bf6fc4899a856ad7254b1769dd0ff8a7990c68fc",
    "_registry": "npm",
    "_loc": "/home/ubuntu/.cache/yarn/v6/npm-@truffle-contract-4.6.20-48237b9d3fe3e5019eac2c8ce9794201ae84fdf8-integrity/node_modules/@truffle/contract/package.json",
    "readmeFilename": "README.md",
    "readme": "# @truffle/contract\n\nBetter Ethereum contract abstraction, for Node and the browser.\n\n### Install\n\n```\n$ npm install @truffle/contract\n```\n\n### Features\n\n- Synchronized transactions for better control flow (i.e., transactions won't finish until you're guaranteed they've been mined).\n- Promises. No more callback hell. Works well with `ES6` and `async/await`.\n- Default values for transactions, like `from` address or `gas`.\n- Returning logs, transaction receipt and transaction hash of every synchronized transaction.\n\n### Usage\n\nFirst, set up a new web3 provider instance and initialize your contract, then `require(\"@truffle/contract\")`.\nThe contract-schema matches the output of the [@truffle/artifactor](https://github.com/trufflesuite/truffle/tree/master/packages/artifactor), so you can pass in the artifact file Truffle produces and stores in the artifact file when you run `truffle compile`.\n\n```javascript\nconst provider = new Web3.providers.HttpProvider(\"http://localhost:8545\");\nconst contractArtifact = require(\"./path/to/contractArtifact.json\"); //produced by Truffle compile\nconst contract = require(\"@truffle/contract\");\n\nconst MyContract = contract(contractArtifact);\n```\n\nIf you aren't using Truffle artifacts, the input to the `contract` function is a JSON blob defined by [@truffle/contract-schema](https://github.com/trufflesuite/truffle/tree/master/packages/contract-schema). This JSON blob is structured in a way that can be passed to all Truffle-related projects.\nMinimally, it requires the contract ABI, but passing this alone may cause issues using certain features of Truffle contract.\n\n```javascript\nconst MyContract = contract({\n  abi: [...], // minimum required\n  address: \"0x...\", // optional\n  // many more\n});\nMyContract.setProvider(provider);\n```\n\nYou now have access to the following functions on `MyContract`, as well as many others:\n\n- `at()`: Create an instance of `MyContract` that represents your contract at a specific address.\n- `deployed()`: Create an instance of `MyContract` that represents the default address managed by `MyContract`.\n- `new()`: Deploy a new version of this contract to the network, getting an instance of `MyContract` that represents the newly deployed instance.\n\nEach instance is tied to a specific address on the Ethereum network, and each instance has a 1-to-1 mapping from Javascript functions to contract functions. For instance, if your Solidity contract had a function defined `someFunction(uint value) {}` (solidity), then you could execute that function on the network like so:\n\n```javascript\nconst instance = await MyContract.deployed();\nconst result = await instance.someFunction(5);\n// Do something with the result or continue with more transactions.\n```\n\n### Browser Usage\n\nIn your `head` element, include @truffle/contract:\n\n```\n<script type=\"text/javascript\" src=\"./dist/truffle-contract.min.js\"></script>\n```\n\nAlternatively, you can use the non-minified versions for easier debugging.\n\nWith this usage, `@truffle/contract` will be available via the `TruffleContract` object:\n\n```\nconst MyContract = TruffleContract(...);\n```\n\n**Note**: Web3 and its dependencies are now bundled into @truffle/contract\nv4.0.2 or higher.\n\n### Full Example\n\nLet's use `@truffle/contract` with an example contract from [Dapps For Beginners](https://dappsforbeginners.wordpress.com/tutorials/your-first-dapp/). In this case, the abstraction has been saved to a `.sol` file by [@truffle/artifactor](https://github.com/trufflesuite/truffle/tree/master/packages/artifactor):\n\n```javascript\nconst contract = require(\"@truffle/contract\");\n// Require the package that was previosly saved by @truffle/artifactor\nconst metacoinArtifact = require(\"./path/to/MetaCoin.json\");\nconst MetaCoin = contract(metacoinArtifact);\n\n// Remember to set the Web3 provider (see above).\nMetaCoin.setProvider(provider);\n\n// In this scenario, two users will send MetaCoin back and forth, showing\n// how @truffle/contract allows for easy control flow.\nconst accountOne = \"5b42bd01ff...\";\nconst accountTwo = \"e1fd0d4a52...\";\n\n// Note our MetaCoin contract exists at a specific address.\nconst contractAddress = \"8e2e2cf785...\";\n\nconst instance = await MetaCoin.at(contractAddress);\n\ntry {\n  // Make a transaction that calls the function `sendCoin`, sending 3 MetaCoin\n  // to the account listed as accountTwo.\n  let result = await instance.sendCoin(accountTwo, 3, { from: accountOne });\n  // This code block will not be executed until @truffle/contract has verified\n  // the transaction has been processed and it is included in a mined block.\n  // @truffle/contract will error if the transaction hasn't been processed in 120 seconds.\n\n  // Since we're using promises, we can return a promise for a call that will\n  // check account two's balance.\n  let balancerOfAccountTwo = await instance.balances.call(accountTwo);\n  console.log(\"Balance of account two is \" + balancerOfAccountTwo + \"!\"); // => 3\n\n  // But maybe too much was sent. Let's send some back.\n  // Like before, will create a transaction that returns a promise, where\n  // the callback won't be executed until the transaction has been processed.\n  result = await instance.sendCoin(accountOne, 1.5, { from: accountTwo });\n  balancerOfAccountTwo = await instance.balances.call(accountTwo);\n  console.log(\"Balance of account two is \" + balancerOfAccountTwo + \"!\"); // => 1.5\n} catch (err) {\n  // Easily catch all errors along the whole execution.\n  console.log(\"ERROR! \" + err.message);\n}\n```\n\n# API\n\nThere are two API's you'll need to be aware of. One is the static Contract Abstraction API and the other is the Contract Instance API. The Abstraction API is a set of functions that exist for all contract abstractions, and those functions exist on the abstraction itself (i.e., `MyContract.at()`). In contrast, the Instance API is the API available to contract instances -- i.e., abstractions that represent a specific contract on the network -- and that API is created dynamically based on functions available in your Solidity source file.\n\n### Contract Abstraction API\n\nEach contract abstraction -- `MyContract` in the examples above -- have the following useful functions:\n\n#### `MyContract.new([arg1, arg2, ...], [tx params])`\n\nThis function take whatever constructor parameters your contract requires and deploys a new instance of the contract to the network. There's an optional last argument which you can use to pass transaction parameters including the transaction from address, gas limit and gas price. This function returns a Promise that resolves into a new instance of the contract abstraction at the newly deployed address.\n\n#### `MyContract.at(address)`\n\nThis function creates a new instance of the contract abstraction representing the contract at the passed in address. Returns a \"thenable\" object (not yet an actual Promise for backward compatibility). Resolves to a contract abstraction instance after ensuring code exists at the specified address.\n\n#### `MyContract.deployed()`\n\nCreates an instance of the contract abstraction representing the contract at its deployed address. The deployed address is a special value given to @truffle/contract that, when set, saves the address internally so that the deployed address can be inferred from the given Ethereum network being used. This allows you to write code referring to a specific deployed contract without having to manage those addresses yourself. Like `at()`, `deployed()` is thenable, and will resolve to a contract abstraction instance representing the deployed contract after ensuring that code exists at that location and that that address exists on the network being used.\n\n#### `MyContract.transactionHash`\n\nThis property accesses the hash of the transaction in which the contract was deployed. This field gets populated for contract objects created with `.deployed()` or `.new()` but not with `.at()`.\n\n#### `MyContract.link(instance)`\n\nLink a library represented by a contract abstraction instance to MyContract. The library must first be deployed and have its deployed address set. The name and deployed address will be inferred from the contract abstraction instance. When this form of `MyContract.link()` is used, MyContract will consume all of the linked library's events and will be able to report that those events occurred during the result of a transaction.\n\nLibraries can be linked multiple times and will overwrite their previous linkage.\n\nNote: This method has two other forms, but this form is recommended.\n\n#### `MyContract.link(name, address)`\n\nLink a library with a specific name and address to MyContract. The library's events will not be consumed using this form.\n\n#### `MyContract.link(object)`\n\nLink multiple libraries denoted by an Object to MyContract. The keys must be strings representing the library names and the values must be strings representing the addresses. Like above, libraries' events will not be consumed using this form.\n\n#### `MyContract.networks()`\n\nView a list of network ids this contract abstraction has been set up to represent.\n\n#### `MyContract.setProvider(provider)`\n\nSets the web3 provider this contract abstraction will use to make transactions.\n\n#### `MyContract.setNetwork(network_id)`\n\nSets the network that MyContract is currently representing.\n\n#### `MyContract.hasNetwork(network_id)`\n\nReturns a boolean denoting whether or not this contract abstraction is set up to represent a specific network.\n\n#### `MyContract.defaults([new_defaults])`\n\nGet's and optionally sets transaction defaults for all instances created from this abstraction. If called without any parameters it will simply return an Object representing current defaults. If an Object is passed, this will set new defaults. Example default transaction values that can be set are:\n\n```javascript\nMyContract.defaults({\n  from: ...,\n  gas: ...,\n  gasPrice: ...,\n  value: ...\n})\n```\n\nSetting a default `from` address, for instance, is useful when you have a contract abstraction you intend to represent one user (i.e., one address).\n\n#### `MyContract.clone(network_id)`\n\nClone a contract abstraction to get another object that manages the same contract artifacts, but using a different `network_id`. This is useful if you'd like to manage the same contract but on a different network. When using this function, don't forget to set the correct provider afterward.\n\n```javascript\nconst MyOtherContract = MyContract.clone(1337);\n```\n\n#### `MyContract.numberFormat = number_type`\n\nYou can set this property to choose the number format that abstraction methods return. The default behavior is to return BN.\n\n```javascript\n// Choices are:  `[\"BigNumber\", \"BN\", \"String\", \"BigInt\"].\nconst Example = artifacts.require(\"Example\");\nExample.numberFormat = \"BigNumber\";\n```\n\n#### `MyContract.timeout(block_timeout)`\n\nThis method allows you to set the block timeout for transactions. Contract instances created from this abstraction will have the specified transaction block timeout. This means that if a transaction does not immediately get mined, it will retry for the specified number of blocks.\n\n#### `MyContract.autoGas = <boolean>`\n\nIf this is set to true, instances created from this abstraction will use `web3.eth.estimateGas` and then apply a gas multiplier to determine the amount of gas to include with the transaction. The default value for this is `true`. See [gasMultiplier](/docs/truffle/reference/contract-abstractions#-code-mycontract-gasmultiplier-gas_multiplier-code-).\n\n#### `MyContract.gasMultiplier(gas_multiplier)`\n\nThis is the value used when `autoGas` is enabled to determine the amount of gas to include with transactions. The gas is computed by using `web3.eth.estimateGas` and multiplying it by the gas multiplier. The default value is `1.25`.\n\n### Contract Instance API\n\nEach contract instance is different based on the source Solidity contract, and the API is created dynamically. For the purposes of this documentation, let's use the following Solidity source code below:\n\n```javascript\ncontract MyContract {\n  uint public value;\n  event ValueSet(uint val);\n  function setValue(uint val) {\n    value = val;\n    emit ValueSet(value);\n  }\n  function getValue() view returns (uint) {\n    return value;\n  }\n}\n```\n\nFrom JavaScript's point of view, this contract has three functions: `setValue`, `getValue` and `value`. This is because `value` is public and automatically creates a getter function for it.\n\n#### Making a transaction via a contract function\n\nWhen we call `setValue()`, this creates a transaction. From JavaScript:\n\n```javascript\nconst result = instance.setValue(5);\nconsole.log(\"Value was set to\", result.logs[0].args.val);\n```\n\nThe result object that gets returned looks like this:\n\n```javascript\n{\n  tx: \"0x6cb0bbb6466b342ed7bc4a9816f1da8b92db1ccf197c3f91914fc2c721072ebd\",\n  receipt: {\n    // The return value from web3.eth.getTransactionReceipt(hash)\n    // See https://github.com/ethereum/wiki/wiki/JavaScript-API#web3ethgettransactionreceipt\n  },\n  logs: [\n    {\n      address: \"0x13274fe19c0178208bcbee397af8167a7be27f6f\",\n      args: {\n        val: BigNumber(5),\n      },\n      blockHash: \"0x2f0700b5d039c6ea7cdcca4309a175f97826322beb49aca891bf6ea82ce019e6\",\n      blockNumber: 40,\n      event: \"ValueSet\",\n      logIndex: 0,\n      transactionHash: \"0x6cb0bbb6466b342ed7bc4a9816f1da8b92db1ccf197c3f91914fc2c721072ebd\",\n      transactionIndex: 0,\n      type:\"mined\",\n    },\n  ],\n}\n```\n\nNote that if the function being executed in the transaction has a return value, you will not get that\nreturn value inside this result. You must instead use an event (like `ValueSet`) and look up the result\nin the `logs` array.\n\n#### Explicitly making a call instead of a transaction\n\nWe can call `setValue()` without creating a transaction by explicitly using `.call`:\n\n```javascript\nconst result = await instance.setValue.call(5);\n```\n\nThis isn't very useful in this case, since `setValue()` sets things, and the value we pass won't be saved since we're not creating a transaction.\n\n#### Calling getters\n\nHowever, we can _get_ the value using `getValue()`, using `.call()`. Calls are always free and don't cost any Ether, so they're good for calling functions that read data off the blockchain:\n\n```javascript\nconst val = instance.getValue.call();\n// val represents the `value` storage object in the solidity contract\n// since the contract returns that value.\n```\n\nEven more helpful, however is we _don't even need_ to use `.call` when a function is marked as `view` or `pure`, because `@truffle/contract` will automatically know that that function can only be interacted with via a call:\n\n```javascript\nconst val = instance.getValue();\n// val reprsents the `value` storage object in the solidity contract\n// since the contract returns that value.\n```\n\n#### Overloaded functions\n\nSolidity supports a contract having multiple functions with the same name as long as the\nfunction argument types differ. And so you may find yourself in the situation of having a\nTruffle contract object with this property.\nYou can invoke these \"overloaded\" functions just like you would a normal contract function. Truffle contract instances\nactually wrap web3's contract abstraction (`web3.eth.Contract`) and when you call an overloaded function, it\nuses the same function resolution that web3 uses. However, we must give a warning that this overloaded function\nresolution is often imprecise and can resolve to the wrong function when you call it.\n\nConsider the following contrived code sample:\n\n```solidity\ncontract MyContract {\n  uint256 public myUint;\n  string public myString;\n  string public myOtherString;\n\n  function setValues(uint256 val, string str) {\n    myUint = val;\n    myString = str\n  }\n\n  function setValues(string str, string otherStr) {\n    myString = str;\n    myOtherString = otherStr;\n  }\n\n  function setValues(uint256 val, string str, string otherStr) {\n    myUint = val;\n    myString = str;\n    myOtherString = otherStr;\n  }\n}\n```\n\nThis Solidity contract contains three functions named `setValues`, each taking a different type of input. In your JavaScript you\nmight do something like the following:\n\n```javascript\nawait instance.setValue(\n  666,\n  \"this is not string cheese\",\n  \"this is string cheese\"\n);\n```\n\nAs mentioned above, Truffle contract wraps web3 `Contract` objects and uses web3's overloaded function resolution.\nTo resolve these functions, web3's strategy is to look at the number of arguments that the function was invoked with and try\none that takes that many arguments. This works for some cases but is not ideal in that it\ncan invoke the incorrect function. Take, for example, the case where we do something like the following:\n\n```javascript\nawait instance.setValue(\"this is not string cheese\", \"this is string cheese\");\n```\n\nWe know that in our contract there are two functions named `setValues` that take\ntwo arguments. In the above case, we cannot be sure whether web3's resolution will resolve to the first or second\nfunction. The more precise way to reference functions like this is to use\nthe `methods` property on the contract instance. The following is an example of how you\naccess these methods:\n\n```javascript\nawait instance.methods[\"setValue(string,string)\"](\n  \"this is not string cheese\",\n  \"this is string cheese\"\n);\n```\n\nThe `methods` property is an object whose keys are strings that correspond to the contract function's names\nand signatures with no spaces. The values are the functions themselves. You can inspect the\n`methods` property to see the key names in this object and match the function signature.\nWe recommend using this method of calling overloaded functions since it will unambiguously resolve to the correct function.\n\n#### Processing transaction results\n\nWhen you make a transaction, you're given a `result` object that gives you a wealth of information about the transaction. You're given the transaction hash (`result.tx`), the decoded events (also known as logs; `result.logs`), and a transaction receipt (`result.receipt`). In the below example, you'll receive the `ValueSet()` event because you triggered the event using the `setValue()` function:\n\n```javascript\nconst result = await instance.setValue(5);\n// result.tx => transaction hash, string\n// result.logs => array of trigger events (1 item in this case)\n// result.receipt => receipt object\n```\n\n#### Sending Ether / Triggering the fallback function\n\nYou can trigger the fallback function by sending a transaction to this function:\n\n```javascript\n// Same result object as above.\nconst result = await instance.sendTransaction({...})\n```\n\nThis is promisified like all available contract instance functions, and has the same API as `web3.eth.sendTransaction` without the callback. The `to` value will be automatically filled in for you.\n\nIf you only want to send Ether to the contract a shorthand is available:\n\n```javascript\n// Same result object as above.\nconst result = await instance.send(web3.toWei(1, \"ether\"));\n```\n\n#### Estimating gas usage\n\nRun this function to estimate the gas usage:\n\n```javascript\n//estimated gas for this transaction\nconst result = await instance.setValue.estimateGas(5);\n```\n\n# Testing\n\nThis package is the result of breaking up EtherPudding into multiple modules. Tests currently reside within [@truffle/artifactor](https://github.com/trufflesuite/truffle/tree/master/packages/artifactor) but will soon move here.\n",
    "licenseText": "Copyright (c) 2017-2019 Truffle Blockchain Group, Inc.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/@truffle/contract/-/contract-4.6.20.tgz#48237b9d3fe3e5019eac2c8ce9794201ae84fdf8",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/@truffle/contract/-/contract-4.6.20.tgz",
    "hash": "48237b9d3fe3e5019eac2c8ce9794201ae84fdf8",
    "integrity": "sha512-s7Mbc37L/CF5Apy/cjPnalkgACmG9tTAmcIW28cIZLRLOUAze18pqhtdHryxAQhEOtKGaDAho6TriqL7/74uHw==",
    "registry": "npm",
    "packageName": "@truffle/contract",
    "cacheIntegrity": "sha512-s7Mbc37L/CF5Apy/cjPnalkgACmG9tTAmcIW28cIZLRLOUAze18pqhtdHryxAQhEOtKGaDAho6TriqL7/74uHw== sha1-SCN7nT/j5QGerCyM6XlCAa6E/fg="
  },
  "registry": "npm",
  "hash": "48237b9d3fe3e5019eac2c8ce9794201ae84fdf8"
}